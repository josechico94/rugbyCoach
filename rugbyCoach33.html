<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Lavagna di Rugby — Animazione + Export JPG/WebM/MP4 + Campo Vertical</title>
  <style>
    :root {
      --sidebar-w: 360px;
      --player-size: 40px;
      --player-font: 14px;
      --blue: #0d6efd;
      --red: #e63946;
      --ink: #e6edf3;
      --panel: #0f1720;
      --panel-2: #111923;
      --border: #1f2a36;
      --shadow: 0 4px 16px rgba(0,0,0,.25);
      --grid: rgba(255,255,255,.08);
      --yellow: #ffd400;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0b1720; color: var(--ink); font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial,"Noto Sans",sans-serif; }
    .app { height: 100dvh; display: grid; grid-template-columns: var(--sidebar-w) 1fr; }

    .sidebar { background: var(--panel-2); border-right: 1px solid var(--border); padding: 16px; display: flex; flex-direction: column; gap: 12px; overflow: auto; z-index: 1000; -webkit-overflow-scrolling: touch; }
    .sidebar h1 { font-size: 18px; margin: 0 0 8px 0; }
    .group { border: 1px solid var(--border); background: var(--panel); border-radius: 12px; padding: 12px; display: grid; gap: 10px; }
    .group strong { font-size: 12px; text-transform: uppercase; letter-spacing: .06em; opacity: .9; }
    .row { display: grid; gap: 8px; }

    .btn, select, input[type="text"], input[type="number"], input[type="range"], label.chk {
      appearance: none; border: 1px solid #263443; background: #15202b; color: var(--ink);
      padding: .55rem .7rem; border-radius: 10px; box-shadow: var(--shadow); font-size: 14px;
    }
    .btn { cursor: pointer; text-align: center; }
    .btn:hover { filter: brightness(1.08); }
    .btn.alt { background: #0e2235; }
    /* Nuevo estilo para indicar herramienta activa */
    .btn.active { background: var(--blue); border-color: var(--blue); }

    small.note { opacity:.8 }
    .legend { display:flex; align-items:center; gap:8px; font-size: 13px; }
    .swatch { width: .9em; height: .9em; border-radius: 50%; display:inline-block; }

    .stage { position: relative; display: grid; place-items: center; padding: 16px; overflow: hidden; }
    /* CORRECCIÓN: Quitamos display:grid y place-items:center para evitar conflicto con la traducción JS */
    .board-viewport { position: relative; width:100%; height:100%; contain: layout paint; }
    .board-wrap { position: absolute; width: 1200px; height: 700px; transform-origin: top left; }
    .board { position: absolute; inset: 0; background: #137a46; overflow: hidden; border-radius: 18px; box-shadow: 0 10px 40px rgba(0,0,0,.4); }

    .board::before {
      content:""; position:absolute; inset:0; pointer-events:none;
      background-image: linear-gradient(90deg, rgba(255,255,255,.02) 0 5%, transparent 5% 10%, rgba(255,255,255,.02) 10% 15%, transparent 15% 20%, rgba(255,255,255,.02) 20% 25%, transparent 25% 30%, rgba(255,255,255,.02) 30% 35%, transparent 35% 40%, rgba(255,255,255,.02) 40% 45%, transparent 45% 50%, rgba(255,255,255,.02) 50% 55%, transparent 55% 60%, rgba(255,255,255,.02) 60% 65%, transparent 65% 70%, rgba(255,255,255,.02) 70% 75%, transparent 75% 80%, rgba(255,255,255,.02) 80% 85%, transparent 85% 90%, rgba(255,255,255,.02) 90% 95%, transparent 95% 100%);
    }
    .grid-overlay { position:absolute; inset:0; pointer-events:none; opacity:.6; display:none; }
    .grid-overlay.active { display:block; }

    .lines, #draw { position:absolute; inset:0; pointer-events:none; }
    svg { width:100%; height:100%; display:block; }

    body, #boardViewport, #boardWrap, #board, #players, #ball, #draw { touch-action:none; }

    #players { position:absolute; inset:0; z-index:3; pointer-events:none; }
    .player { pointer-events:auto; position:absolute; width:40px; height:40px; border-radius:50%; display:grid; place-items:center; font-weight:700; font-size:14px; color:#fff; cursor:grab; border:2px solid #fff; box-shadow: var(--shadow); }
    /* Cursor grabbing al arrastrar */
    .player:active, #ball:active { cursor: grabbing !important; }
    
    #ball { position:absolute; z-index:4; }
    .blue { background: var(--blue); } .red { background: var(--red); }

    .ball { width:50px; height:30px; background: var(--yellow); border: 2px solid #fff; border-radius: 50% / 60%; transform: translate(-50%,-50%) rotate(-15deg); box-shadow: 0 3px 12px rgba(0,0,0,.35); cursor: grab; }
    .ball::after { content:""; position:absolute; inset:6px 18px; border-radius:50% / 60%; border:2px dashed rgba(0,0,0,.25); }
    .label { font-size:12px; font-weight:700; fill:#fff; text-shadow: 0 1px 2px rgba(0,0,0,.6); }

    .hamburger { position: fixed; top: calc(12px + env(safe-area-inset-top)); left: calc(12px + env(safe-area-inset-left)); width: 44px; height: 44px; display:none; place-items:center; font-size:22px; border:1px solid #263443; background:#15202b; color:var(--ink); border-radius:10px; box-shadow: var(--shadow); z-index:1100; }
    .close-drawer { display:none; position: sticky; top:0; margin-left:auto; width:36px; height:36px; border:1px solid #263443; background:#15202b; color:var(--ink); border-radius:10px; box-shadow: var(--shadow); z-index:1001; }
    .scrim { position: fixed; inset:0; background: rgba(0,0,0,.45); opacity:0; pointer-events:none; transition:opacity .2s ease; z-index:900; }
    .scrim.show { opacity:1; pointer-events:auto; }

    @media (max-width: 900px) {
      :root { --sidebar-w: min(86vw, 420px); }
      html, body { overflow:hidden; height:100dvh; }
      .app { grid-template-columns: 1fr; height:100dvh; }
      .sidebar { position: fixed; top:0; left:0; bottom:0; width: var(--sidebar-w); transform: translateX(-105%); transition: transform .25s ease; padding-top: calc(12px + env(safe-area-inset-top)); }
      .sidebar.open { transform: translateX(0); }
      .close-drawer { display:inline-grid; place-items:center; }
      .hamburger { display:inline-grid; }
      .stage { padding:0; }
      .board-viewport { 
        position: fixed; 
        top: 0; 
        left:0; right:0; bottom:0; 
        overflow:hidden; 
        /* CORRECCIÓN: Quitamos display:grid y place-items:center */
        background: #0b1720;
      }
    }
  </style>
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.min.js"></script>
</head>
<body>
  <button id="menuBtn" class="hamburger" aria-label="Apri pannello">☰</button>
  <div id="scrim" class="scrim" aria-hidden="true"></div>

  <div class="app">
    <aside class="sidebar" id="sidebar">
      <button id="closeMenu" class="close-drawer" aria-label="Chiudi">✕</button>
      <h1>Lavagna di Rugby</h1>

      <div class="group">
        <strong>Controlli</strong>
        <div class="row" style="grid-template-columns: 1fr;">
          <button class="btn" id="toggleLabels">Mostra etichette</button>
          <button class="btn alt" id="reset">Reimposta posizioni</button>
        </div>
        <label class="chk" style="display:flex;align-items:center;gap:8px;border:none;background:transparent;padding:0;box-shadow:none">
          <input type="checkbox" id="snapToggle"> Aggancia alla griglia
        </label>
        <label class="chk" style="display:flex;align-items:center;gap:8px;border:none;background:transparent;padding:0;box-shadow:none">
          <input type="checkbox" id="verticalField"> Campo vertical
        </label>
        <div class="legend"><span class="swatch" style="background:#0d6efd"></span> Blu (1–15)</div>
        <div class="legend"><span class="swatch" style="background:#e63946"></span> Rossi (1–15)</div>
      </div>

      <div class="group">
        <strong>Disegno</strong>
        <div class="row" style="grid-template-columns: 1fr 1fr;">
          <button class="btn active" id="toolArrows">Frecce: Attivo</button>
          <button class="btn alt" id="toolPen">Matita: Inattiva</button>
        </div>
        <div class="row" style="grid-template-columns: 1fr 1fr;">
          <label>Colore
            <select id="strokeColor">
              <option value="#ffffff">Bianco</option>
              <option value="#35d07f">Verde</option>
              <option value="#0d6efd">Blu</option>
              <option value="#e63946">Rosso</option>
              <option value="#f4d35e" selected>Giallo</option>
            </select>
          </label>
          <label>Spessore
            <select id="strokeWidth">
              <option value="3">Sottile</option>
              <option value="5" selected>Medio</option>
              <option value="7">Grosso</option>
            </select>
          </label>
        </div>
        <label class="chk" style="border:none;background:transparent;padding:0;box-shadow:none">
          <input type="checkbox" id="dashedToggle"> Linea tratteggiada
        </label>
        <div class="row" style="grid-template-columns: 1fr 1fr;">
          <button class="btn" id="undoGeneric">Annulla</button>
          <button class="btn" id="clearArrows">Cancella frecce</button>
        </div>
        <button class="btn" id="clearAll">Cancella tutto</button>
      </div>

      <div class="group">
        <strong>Giocate</strong>
        <input type="text" id="playName" placeholder="Nome giocada" />
        <div class="row" style="grid-template-columns: 1fr 1fr;">
          <button class="btn" id="savePlay">Salva</button>
          <button class="btn alt" id="duplicatePlay">Duplica</button>
        </div>
        <select id="loadPlay"></select>
        <button class="btn" id="deletePlay">Elimina giocada</button>
      </div>

      <div class="group">
        <strong>Animazione</strong>
        <div class="row" style="grid-template-columns: 1fr 1fr; gap:8px;">
          <button class="btn" id="recordStepBtn">Graba paso</button>
          <label class="chk" style="display:flex;align-items:center;gap:8px;border:none;background:transparent;padding:.4rem .6rem;box-shadow:none">
            <input type="checkbox" id="autoRecord"> Auto al soltar
          </label>
        </div>

        <div class="row" style="grid-template-columns: 1fr 1fr 1fr; gap:8px;">
          <button class="btn" id="playBtn">Play</button>
          <button class="btn alt" id="pauseBtn">Pause</button>
          <button class="btn" id="stopBtn">Stop</button>
        </div>

        <div class="row" style="grid-template-columns: auto 1fr; align-items:center;">
          Velocidad (ms por paso)
          <input type="number" id="speedInput" min="100" step="100" value="800" />
        </div>

        <div class="row" style="grid-template-columns: 1fr; gap:8px;">
          <label>Scrubber (0 → N)
            <input type="range" id="scrubber" min="0" max="0" value="0" />
          </label>
          <div style="display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;">
            <button class="btn alt" id="prevFrameBtn">◀ Anterior</button>
            <div style="text-align:center;">Frame: <span id="scrubberVal">0</span> / <span id="frameTotal">0</span></div>
            <button class="btn alt" id="nextFrameBtn">Siguiente ▶</button>
          </div>
        </div>

        <div class="row" style="grid-template-columns: 1fr 1fr; gap:8px;">
          <button class="btn alt" id="clearTimelineBtn">Limpiar animación</button>
          <button class="btn" id="exportTimelineBtn">Exportar JSON</button>
        </div>
        <button class="btn alt" id="importTimelineBtn">Importar JSON</button>
        <div style="font-size:12px;opacity:.8;">Frames guardados: <span id="frameCount">0</span></div>
      </div>

      <div class="group">
        <strong>Export</strong>
        <div class="row" style="grid-template-columns: 1fr;">
          <button class="btn" id="exportJpgBtn">Exportar imagen (JPG)</button>
          <button class="btn alt" id="exportVideoBtn">Exportar video (WebM)</button>
          <button class="btn" id="exportMp4Btn">Exportar MP4 (beta)</button>
          <small class="note">El video incluye jugadores, pallone, flechas y líneas. MP4 usa ffmpeg.wasm (puede tardar la 1ª vez).</small>
          <div id="ffmpegStatus" class="note"></div>
        </div>
      </div>
    </aside>

    <main class="stage">
      <div class="board-viewport" id="boardViewport">
        <div class="board-wrap" id="boardWrap">
          <div id="board" class="board">
            <svg class="grid-overlay" id="grid" viewBox="0 0 1200 700" preserveAspectRatio="none"></svg>

            <svg class="lines" viewBox="0 0 1200 700" preserveAspectRatio="none" aria-hidden="true">
              <rect x="5" y="5" width="1190" height="690" fill="none" stroke="#fff" stroke-width="6" />
              <rect x="0" y="0" width="80" height="700" fill="rgba(255,255,255,.07)" />
              <rect x="1120" y="0" width="80" height="700" fill="rgba(255,255,255,.07)" />
              <line x1="80" y1="0" x2="80" y2="700" stroke="#fff" stroke-width="4" />
              <line x1="1120" y1="0" x2="1120" y2="700" stroke="#fff" stroke-width="4" />
              <line x1="309" y1="0" x2="309" y2="700" stroke="#fff" stroke-width="3" />
              <line x1="891" y1="0" x2="891" y2="700" stroke="#fff" stroke-width="3" />
              <line x1="500" y1="0" x2="500" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10" />
              <line x1="697" y1="0" x2="697" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10" />
              <line x1="600" y1="0" x2="600" y2="700" stroke="#fff" stroke-width="4" />
              <line x1="5" y1="50" x2="1195" y2="50" stroke="#fff" stroke-width="2" stroke-dasharray="4 8" />
              <line x1="5" y1="150" x2="1195" y2="150" stroke="#fff" stroke-width="2" stroke-dasharray="4 8" />
              <line x1="5" y1="550" x2="1195" y2="550" stroke="#fff" stroke-width="2" stroke-dasharray="4 8" />
              <line x1="5" y1="650" x2="1195" y2="650" stroke="#fff" stroke-width="2" stroke-dasharray="4 8" />
              <line x1="130" y1="0" x2="130" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10"/>
              <line x1="1070" y1="0" x2="1070" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10"/>
            </svg>

            <svg id="draw" viewBox="0 0 1200 700" preserveAspectRatio="none"></svg>
            <div id="players"></div>
            <div id="ball" class="ball" title="Pallone"></div>
          </div>
        </div>
      </div>
      <canvas id="exportCanvas" width="1200" height="700" style="position:fixed; top:-9999px; left:-9999px;"></canvas>
    </main>
  </div>

  <script>
    // --- CONSTANTES GLOBALES ---
    const WIDTH = 1200, HEIGHT = 700;
    const GRID_SIZE = 24;
    const TL_KEY = 'rugby-timeline-v2';
    const POS_KEY = 'rugby-positions-v3';
    const ARROW_KEY = 'rugby-arrows-v3';
    const STROKE_KEY = 'rugby-strokes-v1';
    const BALL_KEY = 'rugby-ball-v1';
    const PLAY_PREFIX = 'play-v3-';

    // --- ESTADO CENTRALIZADO (appState) ---
    let appState = {
        // Layout
        layout: { mode: 'landscape', scale: 1, tx: 0, ty: 0, forceVertical: false },
        // Dibujo
        tool: 'arrows', // 'arrows' o 'pen'
        arrows: [],
        strokes: [],
        drawingArrow: false,
        drawingStroke: false,
        startPoint: null,
        currentStroke: null,
        // Animación
        timeline: [],
        playing: false,
        paused: false,
        playIndex: 0,
        rafId: null,
        segmentStartTime: 0,
        segmentDuration: 800,
        fromFrame: null,
        toFrame: null,
    };

    // --- REFERENCIAS DEL DOM (DOM ELEMENTS) ---
    const dom = {
        // Capas
        boardViewport: document.getElementById('boardViewport'),
        boardWrap: document.getElementById('boardWrap'),
        board: document.getElementById('board'),
        playersLayer: document.getElementById('players'),
        draw: document.getElementById('draw'),
        gridSvg: document.getElementById('grid'),
        ball: document.getElementById('ball'),
        exportCanvas: document.getElementById('exportCanvas'),
        ctx: document.getElementById('exportCanvas').getContext('2d'),
        // Sidebar y Menú
        sidebar: document.getElementById('sidebar'),
        menuBtn: document.getElementById('menuBtn'),
        closeMenuBtn: document.getElementById('closeMenu'),
        scrim: document.getElementById('scrim'),
        // UI Controles
        toggleLabelsBtn: document.getElementById('toggleLabels'),
        resetBtn: document.getElementById('reset'),
        snapToggle: document.getElementById('snapToggle'),
        verticalFieldChk: document.getElementById('verticalField'),
        // UI Dibujo
        toolArrowsBtn: document.getElementById('toolArrows'),
        toolPenBtn: document.getElementById('toolPen'),
        undoGenericBtn: document.getElementById('undoGeneric'),
        clearArrowsBtn: document.getElementById('clearArrows'),
        clearAllBtn: document.getElementById('clearAll'),
        strokeColorSel: document.getElementById('strokeColor'),
        strokeWidthSel: document.getElementById('strokeWidth'),
        dashedToggle: document.getElementById('dashedToggle'),
        // UI Animación
        recordStepBtn: document.getElementById('recordStepBtn'),
        autoRecordChk: document.getElementById('autoRecord'),
        playBtn: document.getElementById('playBtn'),
        pauseBtn: document.getElementById('pauseBtn'),
        stopBtn: document.getElementById('stopBtn'),
        speedInput: document.getElementById('speedInput'),
        clearTimelineBtn: document.getElementById('clearTimelineBtn'),
        exportTimelineBtn: document.getElementById('exportTimelineBtn'),
        importTimelineBtn: document.getElementById('importTimelineBtn'),
        frameCountEl: document.getElementById('frameCount'),
        scrubber: document.getElementById('scrubber'),
        scrubberVal: document.getElementById('scrubberVal'),
        frameTotal: document.getElementById('frameTotal'),
        prevFrameBtn: document.getElementById('prevFrameBtn'),
        nextFrameBtn: document.getElementById('nextFrameBtn'),
        // UI Giocate/Plays
        playNameInput: document.getElementById('playName'),
        loadPlaySel: document.getElementById('loadPlay'),
        savePlayBtn: document.getElementById('savePlay'),
        duplicatePlayBtn: document.getElementById('duplicatePlay'),
        deletePlayBtn: document.getElementById('deletePlay'),
        // UI Export
        exportJpgBtn: document.getElementById('exportJpgBtn'),
        exportVideoBtn: document.getElementById('exportVideoBtn'),
        exportMp4Btn: document.getElementById('exportMp4Btn'),
        ffmpegStatus: document.getElementById('ffmpegStatus'),
    };

    // --- UTILIDADES ---
    function dist(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return Math.hypot(dx, dy); }
    function centerOf(el) { return { x: parseFloat(el.style.left) || 0, y: parseFloat(el.style.top) || 0 }; }
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function ballOverPlayer(playerEl, threshold = 28) {
        const b = centerOf(dom.ball);
        const p = centerOf(playerEl);
        return dist(b.x, b.y, p.x, p.y) < threshold;
    }
    function snap(val) { return Math.round(val / GRID_SIZE) * GRID_SIZE; }

    // --- GESTIÓN DE LAYOUT Y COORDENADAS (LayoutManager) ---
    const LayoutManager = {
        isPortraitLike() {
            if (appState.layout.forceVertical) return true;
            const mq = window.matchMedia('(orientation: portrait)');
            return (mq && mq.matches) || (window.innerHeight > window.innerWidth);
        },
        applyUprightTransforms() {
            const rotatePlayers = (appState.layout.mode === 'portrait');
            [...dom.playersLayer.children].forEach(el => {
                el.style.transform = rotatePlayers
                    ? 'translate(-50%, -50%) rotate(-90deg)'
                    : 'translate(-50%, -50%)';
            });
            // El balón rota por CSS, solo ajustamos su posición.
        },
        fitBoard() {
            const vp = dom.boardViewport.getBoundingClientRect();
            const availW = vp.width;
            const availH = vp.height;

            if (!LayoutManager.isPortraitLike()) {
                // Modo horizontal estándar (Landscape)
                appState.layout.mode = 'landscape';
                appState.layout.scale = Math.min(availW / WIDTH, availH / HEIGHT);
                
                // Calcular la traducción para centrar el tablero
                const scaledW = WIDTH * appState.layout.scale;
                const scaledH = HEIGHT * appState.layout.scale;
                appState.layout.tx = (availW - scaledW) / 2;
                appState.layout.ty = (availH - scaledH) / 2;
                
                dom.boardWrap.style.transform = `translate(${appState.layout.tx}px, ${appState.layout.ty}px) rotate(0deg) scale(${appState.layout.scale})`;
                dom.boardWrap.style.transformOrigin = 'top left';

            } else {
                // Modo Vertical (Portrait) - El board de 1200x700 está ROTADO 90 grados
                appState.layout.mode = 'portrait';
                
                // La dimensión deseada es ahora 700 (ancho) x 1200 (alto)
                const rotW = HEIGHT; // 700
                const rotH = WIDTH;  // 1200

                // La escala debe caber en el viewport: ancho (700) en availW, alto (1200) en availH
                appState.layout.scale = Math.min(availW / rotW, availH / rotH);
                
                // Calcular las dimensiones escaladas
                const contentW = rotW * appState.layout.scale;
                const contentH = rotH * appState.layout.scale;
                
                // Calcular la traslación para centrar el tablero rotado
                const txCenter = (availW - contentW) / 2;
                const tyCenter = (availH - contentH) / 2;
                
                // Traslación final (ajuste de origen + centrado)
                // Aquí el ajuste es crucial: el origen (0,0) del wrap rotado a 90 grados está en la esquina superior derecha del tablero.
                // Necesitamos desplazarlo en X para centrar, y en Y compensar la altura (700px) que ahora es el ancho.
                appState.layout.tx = txCenter + contentW;
                appState.layout.ty = tyCenter;

                // Aplicar transformación
                dom.boardWrap.style.transform = `translate(${appState.layout.tx}px, ${appState.layout.ty}px) rotate(90deg) scale(${appState.layout.scale})`;
                dom.boardWrap.style.transformOrigin = 'top left';
            }
            
            LayoutManager.applyUprightTransforms();
        },
        clientToBoard(e) {
            const vp = dom.boardViewport.getBoundingClientRect();
            const cx = e.clientX - vp.left;
            const cy = e.clientY - vp.top;
            if (appState.layout.mode === 'portrait') {
                // Usamos la traslación inversa para obtener coordenadas sin rotación/escala
                const x_raw = (cx - appState.layout.tx);
                const y_raw = (cy - appState.layout.ty);

                // Aplicar rotación y escala inversas
                const px = y_raw / appState.layout.scale;
                const py = -x_raw / appState.layout.scale;
                
                // Ajuste de traslación inversa (la traslación inicial en Y era la altura del board (700))
                const x = px;
                const y = py ;
                
                return { x: clamp(x, 0, WIDTH), y: clamp(y, 0, HEIGHT) };
            } else {
                const rect = dom.board.getBoundingClientRect();
                // En modo landscape, la escala es la aplicada por fitBoard. La traslación ya está en tx/ty.
                const x = (e.clientX - vp.left - appState.layout.tx) / appState.layout.scale;
                const y = (e.clientY - vp.top - appState.layout.ty) / appState.layout.scale;
                return { x: clamp(x, 0, WIDTH), y: clamp(y, 0, HEIGHT) };
            }
        },
        deltaToBoard(dxClient, dyClient) {
            if (appState.layout.mode === 'portrait') {
                const dx = dyClient / appState.layout.scale; // Invertido y signo invertido por la rotación
                const dy = -dxClient / appState.layout.scale; // Invertido y signo invertido por la rotación
                return { dx, dy };
            } else {
                const rect = dom.board.getBoundingClientRect();
                const scale = rect.width / WIDTH;
                return { dx: dxClient / scale, dy: dyClient / scale };
            }
        },
        renderGrid() {
            const s = GRID_SIZE;
            dom.gridSvg.innerHTML = '';
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            for (let x = s; x < WIDTH; x += s) {
                const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                l.setAttribute('x1', x); l.setAttribute('y1', 0); l.setAttribute('x2', x); l.setAttribute('y2', HEIGHT);
                l.setAttribute('stroke', 'var(--grid)'); l.setAttribute('stroke-width', '1'); g.appendChild(l);
            }
            for (let y = s; y < HEIGHT; y += s) {
                const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                l.setAttribute('x1', 0); l.setAttribute('y1', y); l.setAttribute('x2', WIDTH); l.setAttribute('y2', y);
                l.setAttribute('stroke', 'var(--grid)'); l.setAttribute('stroke-width', '1'); g.appendChild(l);
            }
            dom.gridSvg.appendChild(g);
            dom.gridSvg.classList.toggle('active', dom.snapToggle.checked);
        }
    };

    // --- GESTIÓN DE JUGADORES Y BALÓN (UnitsManager) ---
    const UnitsManager = {
        initialPositions: (function () {
            const positions = [];
            for (let i = 1; i <= 15; i++) positions.push({ team: 'blue', number: i, x: WIDTH * 0.18, y: HEIGHT * (0.1 + (i - 1) * (0.8 / 14)) });
            for (let i = 1; i <= 15; i++) positions.push({ team: 'red', number: i, x: WIDTH * 0.82, y: HEIGHT * (0.1 + (i - 1) * (0.8 / 14)) });
            return positions;
        })(),
        createPlayers() {
            dom.playersLayer.innerHTML = '';
            UnitsManager.initialPositions.forEach(p => {
                const el = document.createElement('div');
                el.className = `player ${p.team}`;
                el.textContent = p.number;
                el.style.left = (p.x) + 'px';
                el.style.top = (p.y) + 'px';
                el.dataset.number = p.number;
                el.dataset.team = p.team;
                UnitsManager.enableDragPlayer(el, () => { StorageManager.savePositions(); if (dom.autoRecordChk.checked) TimelineManager.recordFrame(); });
                dom.playersLayer.appendChild(el);
            });
            LayoutManager.applyUprightTransforms();
        },
        enableDragPlayer(playerEl, onDrop) {
            let pointerId = null, startX = 0, startY = 0, origL = 0, origT = 0;
            let lockBallToPlayer = false;
            let offX = 0, offY = 0;

            const onDown = e => {
                pointerId = e.pointerId;
                playerEl.setPointerCapture(pointerId);
                e.preventDefault();
                startX = e.clientX; startY = e.clientY;
                origL = parseFloat(playerEl.style.left) || 0;
                origT = parseFloat(playerEl.style.top) || 0;

                lockBallToPlayer = ballOverPlayer(playerEl);
                if (lockBallToPlayer) {
                    const p0 = { x: origL, y: origT };
                    const b0 = centerOf(dom.ball);
                    offX = b0.x - p0.x;
                    offY = b0.y - p0.y;
                }

                const onMove = ev => {
                    if (ev.pointerId !== pointerId) return;
                    ev.preventDefault();
                    const { dx, dy } = LayoutManager.deltaToBoard(ev.clientX - startX, ev.clientY - startY);
                    let nx = clamp(origL + dx, 0, WIDTH);
                    let ny = clamp(origT + dy, 0, HEIGHT);
                    playerEl.style.left = nx + 'px';
                    playerEl.style.top = ny + 'px';

                    if (lockBallToPlayer) {
                        const bx = clamp(nx + offX, 0, WIDTH);
                        const by = clamp(ny + offY, 0, HEIGHT);
                        dom.ball.style.left = bx + 'px';
                        dom.ball.style.top = by + 'px';
                    }
                };

                const onUp = ev => {
                    if (ev.pointerId !== pointerId) return;
                    try { playerEl.releasePointerCapture(pointerId); } catch { }
                    document.removeEventListener('pointermove', onMove);
                    document.removeEventListener('pointerup', onUp);

                    if (dom.snapToggle.checked) {
                        const px = snap(parseFloat(playerEl.style.left));
                        const py = snap(parseFloat(playerEl.style.top));
                        playerEl.style.left = px + 'px';
                        playerEl.style.top = py + 'px';
                        if (lockBallToPlayer) {
                            const sbx = clamp(snap(px + offX), 0, WIDTH);
                            const sby = clamp(snap(py + offY), 0, HEIGHT);
                            dom.ball.style.left = sbx + 'px';
                            dom.ball.style.top = sby + 'px';
                        }
                    }
                    (onDrop || (() => { }))();
                };

                document.addEventListener('pointermove', onMove, { passive: false });
                document.addEventListener('pointerup', onUp, { passive: false });
            };

            playerEl.addEventListener('pointerdown', onDown, { passive: false });
            playerEl.ondragstart = () => false;
        },
        placeBall(x = WIDTH * 0.5, y = HEIGHT * 0.5) {
            dom.ball.style.left = x + 'px';
            dom.ball.style.top = y + 'px';
            dom.ball.style.transform = 'translate(-50%, -50%) rotate(-15deg)';
        },
        enableDragBall(onDrop) {
            let pointerId = null, startX = 0, startY = 0, origL = 0, origT = 0;
            let passerEl = null;

            const onDown = e => {
                pointerId = e.pointerId;
                dom.ball.setPointerCapture(pointerId);
                e.preventDefault();
                startX = e.clientX; startY = e.clientY;
                origL = parseFloat(dom.ball.style.left) || 0;
                origT = parseFloat(dom.ball.style.top) || 0;

                const b0 = centerOf(dom.ball);
                passerEl = (function () {
                    let best = null, bestD = Infinity;
                    for (const el of dom.playersLayer.children) {
                        const p = centerOf(el);
                        const d = dist(b0.x, b0.y, p.x, p.y);
                        if (d < 28 && d < bestD) { best = el; bestD = d; }
                    }
                    return best;
                })();

                if (passerEl) {
                    const p = centerOf(passerEl);
                    UnitsManager.setPassPreview(p.x, p.y, b0.x, b0.y);
                }

                const onMove = ev => {
                    if (ev.pointerId !== pointerId) return;
                    ev.preventDefault();
                    const { dx, dy } = LayoutManager.deltaToBoard(ev.clientX - startX, ev.clientY - startY);
                    let nx = clamp(origL + dx, 0, WIDTH);
                    let ny = clamp(origT + dy, 0, HEIGHT);
                    dom.ball.style.left = nx + 'px';
                    dom.ball.style.top = ny + 'px';

                    // Si hay un pasador inicial, dibuja la línea de pase
                    if (passerEl) {
                        const p = centerOf(passerEl);
                        UnitsManager.setPassPreview(p.x, p.y, nx, ny);
                    }
                };

                const onUp = ev => {
                    if (ev.pointerId !== pointerId) return;
                    try { dom.ball.releasePointerCapture(pointerId); } catch { }
                    document.removeEventListener('pointermove', onMove);
                    document.removeEventListener('pointerup', onUp);
                    UnitsManager.clearPassPreview();

                    if (dom.snapToggle.checked) {
                        dom.ball.style.left = snap(parseFloat(dom.ball.style.left)) + 'px';
                        dom.ball.style.top = snap(parseFloat(dom.ball.style.top)) + 'px';
                    }
                    (onDrop || (() => { }))();
                };

                document.addEventListener('pointermove', onMove, { passive: false });
                document.addEventListener('pointerup', onUp, { passive: false });
            };

            dom.ball.addEventListener('pointerdown', onDown, { passive: false });
            dom.ball.ondragstart = () => false;
        },
        setPassPreview(x1, y1, x2, y2) {
            let passEl = document.getElementById('passPreview');
            if (!passEl) {
                passEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                passEl.id = 'passPreview';
                passEl.setAttribute('stroke', 'var(--yellow)');
                passEl.setAttribute('stroke-width', '5');
                passEl.setAttribute('stroke-dasharray', '12 8');
                passEl.style.pointerEvents = 'none';
                dom.draw.prepend(passEl); // Asegurarse de que esté debajo de los dibujos
            }
            passEl.setAttribute('x1', x1);
            passEl.setAttribute('y1', y1);
            passEl.setAttribute('x2', x2);
            passEl.setAttribute('y2', y2);
        },
        clearPassPreview() {
            const passEl = document.getElementById('passPreview');
            if (passEl) passEl.remove();
        }
    };


    // --- GESTIÓN DE DIBUJO (DrawManager) ---
    const DrawManager = {
        clearDraw() {
            dom.draw.innerHTML = '';
            appState.arrows = [];
            appState.strokes = [];
            StorageManager.saveArrows();
            StorageManager.saveStrokes();
        },
        clearArrows() {
            appState.arrows = [];
            DrawManager.renderDraw();
            StorageManager.saveArrows();
        },
        clearStrokes() {
            appState.strokes = [];
            DrawManager.renderDraw();
            StorageManager.saveStrokes();
        },
        setTool(tool) {
            appState.tool = tool;
            dom.toolArrowsBtn.classList.remove('active', 'alt');
            dom.toolPenBtn.classList.remove('active', 'alt');
            if (tool === 'arrows') {
                dom.toolArrowsBtn.classList.add('active');
                dom.toolPenBtn.classList.add('alt');
                dom.toolArrowsBtn.textContent = 'Frecce: Attivo';
                dom.toolPenBtn.textContent = 'Matita: Inattiva';
            } else {
                dom.toolPenBtn.classList.add('active');
                dom.toolArrowsBtn.classList.add('alt');
                dom.toolPenBtn.textContent = 'Matita: Attiva';
                dom.toolArrowsBtn.textContent = 'Frecce: Inattive';
            }
            // Activar captura de eventos de puntero solo cuando dibujamos
            if (tool === 'arrows' || tool === 'pen') dom.draw.style.pointerEvents = 'auto';
            else dom.draw.style.pointerEvents = 'none';
        },
        undoLast() {
            if (appState.arrows.length > appState.strokes.length) {
                appState.arrows.pop();
                StorageManager.saveArrows();
            } else if (appState.strokes.length > 0) {
                appState.strokes.pop();
                StorageManager.saveStrokes();
            }
            DrawManager.renderDraw();
        },
        renderDraw() {
            dom.draw.innerHTML = '';
            // Renderizar Strokes (Líneas a mano alzada)
            appState.strokes.forEach(stroke => {
                const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                const points = stroke.points.map(p => `${p.x},${p.y}`).join(' ');
                polyline.setAttribute('points', points);
                polyline.setAttribute('fill', 'none');
                polyline.setAttribute('stroke', stroke.color);
                polyline.setAttribute('stroke-width', stroke.width);
                polyline.setAttribute('stroke-linecap', 'round');
                polyline.setAttribute('stroke-linejoin', 'round');
                if (stroke.dashed) polyline.setAttribute('stroke-dasharray', '12 8');
                dom.draw.appendChild(polyline);
            });

            // Renderizar Arrows (Flechas)
            appState.arrows.forEach(arrow => {
                const { x1, y1, x2, y2, color, width, dashed } = arrow;
                // Linea
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                line.setAttribute('stroke', color); line.setAttribute('stroke-width', width);
                line.setAttribute('stroke-linecap', 'round');
                if (dashed) line.setAttribute('stroke-dasharray', '12 8');
                dom.draw.appendChild(line);

                // Punta de flecha (basado en el ángulo)
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const size = width * 2.5;
                const head = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const points = [
                    `${x2},${y2}`,
                    `${x2 - size * Math.cos(angle - Math.PI / 6)},${y2 - size * Math.sin(angle - Math.PI / 6)}`,
                    `${x2 - size * Math.cos(angle + Math.PI / 6)},${y2 - size * Math.sin(angle + Math.PI / 6)}`
                ];
                head.setAttribute('points', points.join(' '));
                head.setAttribute('fill', color);
                dom.draw.appendChild(head);
            });
            // Ocultar el preview de pase si existe
            UnitsManager.clearPassPreview();
        },
        enableDrawing() {
            dom.draw.addEventListener('pointerdown', DrawManager.onPointerDown, { passive: false });
            dom.draw.addEventListener('pointerup', DrawManager.onPointerUp, { passive: false });
        },
        onPointerDown(e) {
            if (e.button !== 0) return; // Solo click izquierdo
            e.preventDefault();
            const { x, y } = LayoutManager.clientToBoard(e);
            appState.startPoint = { x, y };

            if (appState.tool === 'arrows') {
                appState.drawingArrow = true;
                DrawManager.drawArrowPreview(x, y, x, y);
            } else if (appState.tool === 'pen') {
                appState.drawingStroke = true;
                appState.currentStroke = {
                    points: [{ x, y }],
                    color: dom.strokeColorSel.value,
                    width: dom.strokeWidthSel.value,
                    dashed: dom.dashedToggle.checked
                };
            }

            const onMove = ev => {
                if (ev.pointerId !== e.pointerId) return;
                ev.preventDefault();
                const { x, y } = LayoutManager.clientToBoard(ev);
                const currX = clamp(x, 0, WIDTH);
                const currY = clamp(y, 0, HEIGHT);
                if (appState.tool === 'arrows' && appState.drawingArrow) {
                    DrawManager.drawArrowPreview(appState.startPoint.x, appState.startPoint.y, currX, currY);
                } else if (appState.tool === 'pen' && appState.drawingStroke) {
                    appState.currentStroke.points.push({ x: currX, y: currY });
                    DrawManager.drawStrokePreview(appState.currentStroke);
                }
            };

            const onUp = ev => {
                if (ev.pointerId !== e.pointerId) return;
                document.removeEventListener('pointermove', onMove);
                document.removeEventListener('pointerup', onUp);
                DrawManager.clearPreview();

                const { x, y } = LayoutManager.clientToBoard(ev);
                const endX = clamp(x, 0, WIDTH);
                const endY = clamp(y, 0, HEIGHT);

                if (appState.tool === 'arrows' && appState.drawingArrow) {
                    if (dist(appState.startPoint.x, appState.startPoint.y, endX, endY) > 10) {
                        appState.arrows.push({
                            x1: appState.startPoint.x, y1: appState.startPoint.y,
                            x2: endX, y2: endY,
                            color: dom.strokeColorSel.value,
                            width: dom.strokeWidthSel.value,
                            dashed: dom.dashedToggle.checked
                        });
                        StorageManager.saveArrows();
                    }
                    appState.drawingArrow = false;
                } else if (appState.tool === 'pen' && appState.drawingStroke) {
                    if (appState.currentStroke.points.length > 1) {
                        appState.strokes.push(appState.currentStroke);
                        StorageManager.saveStrokes();
                    }
                    appState.drawingStroke = false;
                    appState.currentStroke = null;
                }
                DrawManager.renderDraw();
            };

            document.addEventListener('pointermove', onMove, { passive: false });
            document.addEventListener('pointerup', onUp, { passive: false });
        },
        drawArrowPreview(x1, y1, x2, y2) {
            let line = document.getElementById('arrowPreviewLine');
            let head = document.getElementById('arrowPreviewHead');
            if (!line) {
                line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                head = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                line.id = 'arrowPreviewLine';
                head.id = 'arrowPreviewHead';
                dom.draw.appendChild(line);
                dom.draw.appendChild(head);
            }
            const color = dom.strokeColorSel.value;
            const width = dom.strokeWidthSel.value;
            const dashed = dom.dashedToggle.checked;

            // Linea
            line.setAttribute('x1', x1); line.setAttribute('y1', y1);
            line.setAttribute('x2', x2); line.setAttribute('y2', y2);
            line.setAttribute('stroke', color); line.setAttribute('stroke-width', width);
            line.setAttribute('stroke-linecap', 'round');
            if (dashed) line.setAttribute('stroke-dasharray', '12 8'); else line.removeAttribute('stroke-dasharray');

            // Punta de flecha (basado en el ángulo)
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const size = width * 2.5;
            const points = [
                `${x2},${y2}`,
                `${x2 - size * Math.cos(angle - Math.PI / 6)},${y2 - size * Math.sin(angle - Math.PI / 6)}`,
                `${x2 - size * Math.cos(angle + Math.PI / 6)},${y2 - size * Math.sin(angle + Math.PI / 6)}`
            ];
            head.setAttribute('points', points.join(' '));
            head.setAttribute('fill', color);
        },
        drawStrokePreview(stroke) {
            let polyline = document.getElementById('strokePreview');
            if (!polyline) {
                polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                polyline.id = 'strokePreview';
                dom.draw.appendChild(polyline);
            }
            const points = stroke.points.map(p => `${p.x},${p.y}`).join(' ');
            polyline.setAttribute('points', points);
            polyline.setAttribute('fill', 'none');
            polyline.setAttribute('stroke', stroke.color);
            polyline.setAttribute('stroke-width', stroke.width);
            polyline.setAttribute('stroke-linecap', 'round');
            polyline.setAttribute('stroke-linejoin', 'round');
            if (stroke.dashed) polyline.setAttribute('stroke-dasharray', '12 8'); else polyline.removeAttribute('stroke-dasharray');
        },
        clearPreview() {
            const arr = document.getElementById('arrowPreviewLine'); if (arr) arr.remove();
            const head = document.getElementById('arrowPreviewHead'); if (head) head.remove();
            const strk = document.getElementById('strokePreview'); if (strk) strk.remove();
        }
    };


    // --- GESTIÓN DE ANIMACIÓN (TimelineManager) ---
    const TimelineManager = {
        recordFrame() {
            // Captura el estado actual
            const players = [...dom.playersLayer.children].map(el => ({
                team: el.dataset.team, number: +el.dataset.number,
                x: parseFloat(el.style.left), y: parseFloat(el.style.top)
            }));
            const ball = { x: parseFloat(dom.ball.style.left) || WIDTH / 2, y: parseFloat(dom.ball.style.top) || HEIGHT / 2 };
            const arrows = JSON.parse(JSON.stringify(appState.arrows));
            const strokes = JSON.parse(JSON.stringify(appState.strokes));

            // Si es un cuadro intermedio, lo inserta en la posición actual del scrubber
            if (appState.playIndex < appState.timeline.length) {
                appState.timeline.splice(appState.playIndex, 0, { players, ball, arrows, strokes });
                appState.playIndex++; // Mover al nuevo frame
            } else {
                appState.timeline.push({ players, ball, arrows, strokes });
                appState.playIndex = appState.timeline.length;
            }

            TimelineManager.updateScrubber();
            StorageManager.saveTimeline();
        },
        clearTimeline() {
            if (!confirm('¿Estás seguro de que quieres eliminar la animación? Esto no afecta las posiciones de inicio.')) return;
            appState.timeline = [];
            appState.playIndex = 0;
            TimelineManager.updateScrubber();
            StorageManager.saveTimeline();
        },
        renderInterpolatedFrame(fromIndex, t) {
            // Clamp t
            if (isNaN(t)) t = 0;
            if (t < 0) t = 0;
            if (t > 1) t = 1;

            const f0 = appState.timeline[fromIndex];
            const f1 = appState.timeline[fromIndex + 1];
            if (!f0 || !f1) {
                // fallback: mostrar frame actual
                if (f0) TimelineManager.loadFrame(fromIndex);
                return;
            }

            // Interpolar jugadores
            const playersMap = new Map();
            [...dom.playersLayer.children].forEach(el => playersMap.set(el.dataset.team + el.dataset.number, el));
            f0.players.forEach(p0 => {
                const el = playersMap.get(p0.team + p0.number);
                if (el) {
                    const p1 = f1.players.find(pp => pp.team === p0.team && pp.number === p0.number) || p0;
                    const ix = p0.x + (p1.x - p0.x) * t;
                    const iy = p0.y + (p1.y - p0.y) * t;
                    el.style.left = ix + 'px';
                    el.style.top = iy + 'px';
                }
            });

            // Interpolar balón
            const bx = f0.ball.x + (f1.ball.x - f0.ball.x) * t;
            const by = f0.ball.y + (f1.ball.y - f0.ball.y) * t;
            UnitsManager.placeBall(bx, by);

            // Dibujos: mantener los del frame origen (consistente y simple)
            appState.arrows = JSON.parse(JSON.stringify(f0.arrows));
            appState.strokes = JSON.parse(JSON.stringify(f0.strokes));
            DrawManager.renderDraw();

            // UI y rotación
            appState.playIndex = fromIndex;
            TimelineManager.updateScrubber();
            LayoutManager.applyUprightTransforms();
        },
        loadFrame(index) {
            const frame = appState.timeline[index];
            if (!frame) return;

            // Cargar Posiciones
            const playersMap = new Map();
            [...dom.playersLayer.children].forEach(el => playersMap.set(el.dataset.team + el.dataset.number, el));
            frame.players.forEach(p => {
                const el = playersMap.get(p.team + p.number);
                if (el) {
                    el.style.left = p.x + 'px';
                    el.style.top = p.y + 'px';
                }
            });

            // Cargar Balón
            UnitsManager.placeBall(frame.ball.x, frame.ball.y);

            // Cargar Dibujos
            appState.arrows = JSON.parse(JSON.stringify(frame.arrows));
            appState.strokes = JSON.parse(JSON.stringify(frame.strokes));
            DrawManager.renderDraw();

            appState.playIndex = index;
            TimelineManager.updateScrubber();
            LayoutManager.applyUprightTransforms();
        },
        updateScrubber() {
            const count = appState.timeline.length;
            dom.frameCountEl.textContent = count;
            dom.frameTotal.textContent = count;
            dom.scrubber.max = Math.max(0, count - 1);
            dom.scrubber.value = appState.playIndex;
            dom.scrubberVal.textContent = appState.playIndex;
            if (count === 0) dom.scrubber.value = 0;
        },
        handleScrubberChange(e) {
            const index = parseInt(e.target.value);
            if (index !== appState.playIndex && index < appState.timeline.length) {
                TimelineManager.loadFrame(index);
            }
        },
        play(timestamp) {
            if (!appState.playing || appState.timeline.length < 2) {
                appState.playing = false;
                appState.paused = false;
                dom.playBtn.textContent = 'Play';
                return;
            }

            if (appState.paused) return;

            const dur = (isNaN(appState.segmentDuration) || appState.segmentDuration < 16) ? 800 : appState.segmentDuration;

            // Inicializar una sola vez desde el scrubber actual (si es inválido, usar 0)
            if (appState.fromFrame == null) {
                if (isNaN(appState.playIndex) || appState.playIndex < 0 || appState.playIndex >= appState.timeline.length - 1) {
                    appState.playIndex = 0;
                }
                appState.fromFrame = appState.playIndex;
                appState.segmentStartTime = timestamp;
                // Render inicial (t=0)
                TimelineManager.renderInterpolatedFrame(appState.fromFrame, 0);
            }

            // Si estamos en el último frame (no hay siguiente), finalizar
            if (appState.fromFrame >= appState.timeline.length - 1) {
                appState.playing = false;
                appState.paused = false;
                appState.fromFrame = null;
                dom.playBtn.textContent = 'Play';
                TimelineManager.updateScrubber();
                return;
            }

            const elapsed = timestamp - appState.segmentStartTime;
            let t = elapsed / dur;

            if (t >= 1) {
                // Avanzar al siguiente segmento
                appState.fromFrame += 1;
                appState.playIndex = appState.fromFrame;
                appState.segmentStartTime = timestamp;

                if (appState.fromFrame >= appState.timeline.length - 1) {
                    // Cargar último frame exacto y terminar
                    TimelineManager.loadFrame(appState.playIndex);
                    appState.playing = false;
                    appState.paused = false;
                    appState.fromFrame = null;
                    dom.playBtn.textContent = 'Play';
                    TimelineManager.updateScrubber();
                    return;
                } else {
                    // Render del nuevo segmento (t=0)
                    TimelineManager.renderInterpolatedFrame(appState.fromFrame, 0);
                }
            } else {
                // Render interpolado entre fromFrame y fromFrame+1
                TimelineManager.renderInterpolatedFrame(appState.fromFrame, t);
            }

            appState.rafId = requestAnimationFrame(TimelineManager.play);
        },
        startPlay() {
            if (appState.timeline.length < 2) return;
            const val = parseInt(dom.speedInput.value);
            appState.segmentDuration = (isNaN(val) || val < 16) ? 800 : val;
            appState.playing = true;
            appState.paused = false;
            appState.fromFrame = null;
            dom.playBtn.textContent = 'Playing...';
            cancelAnimationFrame(appState.rafId);
            appState.rafId = requestAnimationFrame(TimelineManager.play);
        },
        pausePlay() {
            appState.paused = true;
            try { cancelAnimationFrame(appState.rafId); } catch (e) {}
            dom.playBtn.textContent = 'Play';
            dom.pauseBtn.textContent = 'Paused';
        },
        stopPlay() {
            appState.playing = false;
            appState.paused = false;
            appState.fromFrame = null;
            try { cancelAnimationFrame(appState.rafId); } catch (e) {}
            appState.fromFrame = null;
            dom.playBtn.textContent = 'Play';
            dom.pauseBtn.textContent = 'Pause';
            cancelAnimationFrame(appState.rafId);
            TimelineManager.loadFrame(0);
        }
    };


    // --- GESTIÓN DE ALMACENAMIENTO (StorageManager) ---
    const StorageManager = {
        savePositions() {
            const positions = [...dom.playersLayer.children].map(el => ({
                team: el.dataset.team, number: +el.dataset.number,
                x: parseFloat(el.style.left), y: parseFloat(el.style.top)
            }));
            localStorage.setItem(POS_KEY, JSON.stringify(positions));
        },
        loadPositions() {
            const saved = localStorage.getItem(POS_KEY);
            if (!saved) { UnitsManager.createPlayers(); return; }

            const positions = JSON.parse(saved);
            const playersMap = new Map();
            UnitsManager.createPlayers(); // Crear los elementos primero

            [...dom.playersLayer.children].forEach(el => playersMap.set(el.dataset.team + el.dataset.number, el));

            positions.forEach(p => {
                const el = playersMap.get(p.team + p.number);
                if (el) {
                    el.style.left = p.x + 'px';
                    el.style.top = p.y + 'px';
                }
            });
            LayoutManager.applyUprightTransforms();
        },
        saveBall() {
            const ball = centerOf(dom.ball);
            localStorage.setItem(BALL_KEY, JSON.stringify(ball));
        },
        loadBall() {
            const saved = localStorage.getItem(BALL_KEY);
            if (!saved) return;
            const pos = JSON.parse(saved);
            UnitsManager.placeBall(pos.x, pos.y);
        },
        saveArrows() { localStorage.setItem(ARROW_KEY, JSON.stringify(appState.arrows)); },
        loadArrows() {
            const saved = localStorage.getItem(ARROW_KEY);
            if (saved) appState.arrows = JSON.parse(saved);
        },
        saveStrokes() { localStorage.setItem(STROKE_KEY, JSON.stringify(appState.strokes)); },
        loadStrokes() {
            const saved = localStorage.getItem(STROKE_KEY);
            if (saved) appState.strokes = JSON.parse(saved);
        },
        saveTimeline() {
            localStorage.setItem(TL_KEY, JSON.stringify(appState.timeline));
        },
        loadTimeline() {
            const saved = localStorage.getItem(TL_KEY);
            if (saved) appState.timeline = JSON.parse(saved);
            TimelineManager.updateScrubber();
        },
        exportTimeline() {
            const json = JSON.stringify(appState.timeline, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = (dom.playNameInput.value?.trim() || 'lavagna') + '_animazione.json';
            document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
        },
        importTimeline() {
            const input = document.createElement('input');
            input.type = 'file'; input.accept = 'application/json';
            input.onchange = e => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = e => {
                    try {
                        const json = e.target.result;
                        const timeline = JSON.parse(json);
                        if (Array.isArray(timeline) && timeline.every(f => f.players && f.ball)) {
                            appState.timeline = timeline;
                            StorageManager.saveTimeline();
                            TimelineManager.loadFrame(0);
                            alert(`Animazione importata: ${timeline.length} frames.`);
                        } else {
                            throw new Error("Formato JSON non valido per la timeline.");
                        }
                    } catch (err) {
                        alert(`Errore nell'importazione: ${err.message}`);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        },
        savePlay() {
            const name = dom.playNameInput.value?.trim();
            if (!name) { alert('Inserisci un nome per la giocata.'); return; }
            if (appState.timeline.length === 0) { alert('Aggiungi almeno un frame all\'animazione per salvare la giocata.'); return; }
            
            const playData = {
                name,
                timeline: appState.timeline,
                arrows: appState.arrows,
                strokes: appState.strokes,
                positions: [...dom.playersLayer.children].map(el => ({ team: el.dataset.team, number: +el.dataset.number, x: parseFloat(el.style.left), y: parseFloat(el.style.top) })),
                ball: centerOf(dom.ball),
            };

            try {
                localStorage.setItem(PLAY_PREFIX + name, JSON.stringify(playData));
                StorageManager.updatePlaySelect();
                alert(`Giocata "${name}" salvata con successo.`);
            } catch (e) {
                alert('Errore nel salvataggio. Memoria piena o nome non valido.');
            }
        },
        loadPlay(name) {
            const rawData = localStorage.getItem(PLAY_PREFIX + name);
            if (!rawData) return;
            const playData = JSON.parse(rawData);

            // 1. Carica Timeline
            appState.timeline = playData.timeline || [];
            TimelineManager.updateScrubber();
            
            // 2. Carica Disegni
            appState.arrows = playData.arrows || [];
            appState.strokes = playData.strokes || [];
            
            // 3. Carga Posiciones y Ball (usando el primer frame de la timeline si existe, sino las de `positions`/`ball` si existen)
            if (appState.timeline.length > 0) {
                TimelineManager.loadFrame(0);
            } else if (playData.positions) {
                const playersMap = new Map();
                [...dom.playersLayer.children].forEach(el => playersMap.set(el.dataset.team + el.dataset.number, el));
                playData.positions.forEach(p => {
                    const el = playersMap.get(p.team + p.number);
                    if (el) {
                        el.style.left = p.x + 'px';
                        el.style.top = p.y + 'px';
                    }
                });
                UnitsManager.placeBall(playData.ball.x, playData.ball.y);
                DrawManager.renderDraw();
            } else {
                // Si no hay nada, al menos renderiza los dibujos cargados
                DrawManager.renderDraw();
            }

            dom.playNameInput.value = name;
            StorageManager.saveTimeline();
            StorageManager.saveArrows();
            StorageManager.saveStrokes();
            StorageManager.savePositions();
            StorageManager.saveBall();
            LayoutManager.applyUprightTransforms();
        },
        duplicatePlay() {
            const originalName = dom.playNameInput.value?.trim();
            if (!originalName) { alert('Carica prima una giocata per duplicarla.'); return; }
            const newName = prompt(`Duplicar "${originalName}" como:`);
            if (newName && newName.trim()) {
                const rawData = localStorage.getItem(PLAY_PREFIX + originalName);
                if (rawData) {
                    localStorage.setItem(PLAY_PREFIX + newName.trim(), rawData);
                    dom.playNameInput.value = newName.trim();
                    StorageManager.updatePlaySelect();
                    dom.loadPlaySel.value = newName.trim();
                    alert(`Giocata duplicata como "${newName.trim()}".`);
                }
            }
        },
        deletePlay() {
            const name = dom.loadPlaySel.value;
            if (name && confirm(`¿Estás seguro de que quieres eliminar la giocata "${name}"?`)) {
                localStorage.removeItem(PLAY_PREFIX + name);
                StorageManager.updatePlaySelect();
                dom.playNameInput.value = '';
                alert(`Giocata "${name}" eliminada.`);
            }
        },
        updatePlaySelect() {
            dom.loadPlaySel.innerHTML = '<option value="">-- Carica giocata salvata --</option>';
            const plays = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(PLAY_PREFIX)) {
                    plays.push(key.substring(PLAY_PREFIX.length));
                }
            }
            plays.sort().forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                dom.loadPlaySel.appendChild(option);
            });
        }
    };


    // --- EXPORTACIÓN (ExportManager) ---
    const ExportManager = {
        // --- Funciones de dibujo a Canvas ---
        drawPitch(ctx) {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            // Fondo de campo (Verde)
            ctx.fillStyle = '#137a46'; 
            ctx.fillRect(0, 0, WIDTH, HEIGHT); 

            // Obtener el contenido SVG del campo (líneas)
            const svgEl = dom.board.querySelector('.lines');
            if (!svgEl) return;

            // Inyectar etiquetas si están activadas (para consistencia con el DOM visible)
            let tempLabels = [];
            if (dom.toggleLabelsBtn.classList.contains('active')) {
                [...dom.playersLayer.children].forEach(el => {
                    const rect = el.getBoundingClientRect();
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.classList.add('label');
                    label.setAttribute('x', parseFloat(el.style.left) - 10); 
                    label.setAttribute('y', parseFloat(el.style.top) + 25); 
                    label.textContent = el.textContent;
                    svgEl.appendChild(label);
                    tempLabels.push(label);
                });
            }

            const svgData = new XMLSerializer().serializeToString(svgEl);
            const img = new Image();
            
            // Usar un temporal Promise/Callback para esperar a que el SVG se cargue como imagen
            return new Promise(resolve => {
                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                    tempLabels.forEach(l => l.remove()); // Limpiar etiquetas inyectadas
                    resolve();
                };
                img.onerror = (e) => {
                    console.error("Error cargando SVG del campo en canvas:", e);
                    tempLabels.forEach(l => l.remove()); // Limpiar etiquetas inyectadas incluso en error
                    resolve(); // Resuelve para no bloquear la exportación
                };
                img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
            });
        },
        drawPlayer(ctx, p) {
            const size = 40;
            const radius = size / 2;
            const font = 'bold 14px system-ui';
            
            ctx.save();
            ctx.translate(p.x, p.y);
            
            // En modo vertical, los jugadores están rotados -90deg. Hay que compensar.
            // Esto solo aplica si se está exportando una imagen estática con la rotación del canvas/wrap no aplicada. 
            // Como el canvas de exportación es plano (no rotado), no rotamos aquí a menos que queramos el texto girado.
            // Dejamos la rotación fuera para que el número se vea derecho.

            // Círculo
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
            ctx.fillStyle = (p.team === 'blue' ? '#0d6efd' : '#e63946');
            ctx.fill();

            // Borde
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Número
            ctx.fillStyle = '#fff';
            ctx.font = font;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(p.number, 0, 1);
            
            ctx.restore();
        },
        drawBall(ctx, b) {
            const W = 50, H = 30;
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(-15 * Math.PI / 180); // Rotación de CSS

            // Balón (elipse aproximada)
            ctx.beginPath();
            ctx.ellipse(0, 0, W / 2, H / 2, 0, 0, Math.PI * 2);
            ctx.fillStyle = '#ffd400';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Cordones/Borde interno (aproximación)
            ctx.beginPath();
            ctx.setLineDash([8, 6]);
            ctx.ellipse(0, 0, W / 2 - 6, H / 2 - 6, 0, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(0,0,0,.25)';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        },
        drawStroke(ctx, s) {
            if (s.points.length < 2) return;
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(s.points[0].x, s.points[0].y);
            for (let i = 1; i < s.points.length; i++) {
                ctx.lineTo(s.points[i].x, s.points[i].y);
            }
            ctx.strokeStyle = s.color;
            ctx.lineWidth = s.width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            if (s.dashed) ctx.setLineDash([12, 8]);
            ctx.stroke();
            ctx.restore();
        },
        drawArrow(ctx, a) {
            const { x1, y1, x2, y2, color, width, dashed } = a;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const size = width * 2.5;

            ctx.save();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            if (dashed) ctx.setLineDash([12, 8]);

            // Linea
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Punta de flecha
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - size * Math.cos(angle - Math.PI / 6), y2 - size * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - size * Math.cos(angle + Math.PI / 6), y2 - size * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        },

        getCurrentPlayersFromDOM() { return [...dom.playersLayer.children].map(el => ({ team: el.dataset.team, number: +el.dataset.number, x: parseFloat(el.style.left), y: parseFloat(el.style.top) })); },
        getCurrentBallFromDOM() { return { x: parseFloat(dom.ball.style.left) || WIDTH / 2, y: parseFloat(dom.ball.style.top) || HEIGHT / 2 }; },

        async renderFrameToCanvas(playersArr, ballPos, includeOverlays = true) {
            // Limpia y dibuja el pitch primero (asíncrono porque espera la carga del SVG)
            await ExportManager.drawPitch(dom.ctx); 
            
            // Dibuja el resto de elementos
            playersArr.forEach(p => ExportManager.drawPlayer(dom.ctx, p)); 
            ExportManager.drawBall(dom.ctx, ballPos);
            
            if (includeOverlays) { 
                appState.strokes.forEach(s => ExportManager.drawStroke(dom.ctx, s)); 
                appState.arrows.forEach(a => ExportManager.drawArrow(dom.ctx, a)); 
            }
        },

        // --- Lógica de Exportación ---

        setupExportUI() {
            
            // Deshabilitar MP4 si FFmpeg no está presente
            if (!window.FFmpeg) {
                dom.exportMp4Btn.disabled = true;
                dom.exportMp4Btn.textContent = 'Exportar MP4 (instalar ffmpeg.wasm)';
            }
dom.exportJpgBtn.addEventListener('click', async () => {
                const playersNow = ExportManager.getCurrentPlayersFromDOM();
                const ballNow = ExportManager.getCurrentBallFromDOM();
                
                // Renderiza el frame actual en el canvas
                await ExportManager.renderFrameToCanvas(playersNow, ballNow, true);
                
                // Exporta la imagen del canvas
                const url = dom.exportCanvas.toDataURL('image/jpeg', 0.95);
                const a = document.createElement('a'); a.href = url; 
                a.download = (dom.playNameInput.value?.trim() || 'lavagna') + '_frame.jpg'; 
                document.body.appendChild(a); a.click(); a.remove();
            });

            // Lógica de exportación WebM...
            dom.exportVideoBtn.addEventListener('click', async () => {
                if (appState.timeline.length < 2) { alert('Añade al menos 2 frames a la animación para exportar video.'); return; }
                if (!window.MediaRecorder) { alert('Tu navegador no soporta MediaRecorder para exportar WebM.'); return; }

                const stream = dom.exportCanvas.captureStream(30); // 30 FPS
                const recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
                const chunks = [];
                let isRecording = true;
                
                dom.exportVideoBtn.textContent = 'Grabando...';
                dom.exportVideoBtn.disabled = true;

                recorder.ondataavailable = e => chunks.push(e.data);
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); a.href = url;
                    a.download = (dom.playNameInput.value?.trim() || 'lavagna') + '_animazione.webm';
                    document.body.appendChild(a); a.click(); a.remove();
                    URL.revokeObjectURL(url);
                    dom.exportVideoBtn.textContent = 'Exportar video (WebM)';
                    dom.exportVideoBtn.disabled = false;
                    TimelineManager.loadFrame(0); // Vuelve al frame 0
                };

                recorder.start();
                
                // Duración y control de frames
                const duration = parseInt(dom.speedInput.value);
                const totalFrames = appState.timeline.length;
                let currentFrame = 0;

                const runFrame = async () => {
                    if (currentFrame >= totalFrames || !isRecording) {
                        recorder.stop();
                        return;
                    }

                    // Renderiza el frame actual
                    const frameData = appState.timeline[currentFrame];
                    await ExportManager.renderFrameToCanvas(frameData.players, frameData.ball, true);
                    
                    currentFrame++;
                    setTimeout(runFrame, duration);
                };
                
                // Iniciar la grabación
                await runFrame();

            });

            // Lógica de exportación MP4 con FFmpeg... (Mantenida sin cambios en la parte FFmpeg)
            dom.exportMp4Btn.addEventListener('click', () => {
  // Exportación MP4 en PÁGINA SEPARADA para no congelar la app
  const win = window.open('exporter_mp4.html', '_blank', 'noopener');
  if (!win) { alert('No pude abrir el exportador (popup bloqueado). Permití popups para este sitio.'); return; }
  const payload = {
    timeline: appState.timeline,
    width: WIDTH,
    height: HEIGHT,
    segmentDuration: (isNaN(appState.segmentDuration) ? 800 : appState.segmentDuration),
    name: (dom.playNameInput?.value?.trim() || 'lavagna')
  };
  function onReady(e){
    if (e.source === win && e.data === 'EXPORTER_READY'){
      window.removeEventListener('message', onReady);
      win.postMessage(payload, '*');
    }
  }
  window.addEventListener('message', onReady);
});

        },
    };


    // --- UI/EVENT HANDLERS ---
    const UIManager = {
        setupEventListeners() {
            // Layout
            window.addEventListener('resize', LayoutManager.fitBoard);
            dom.verticalFieldChk.addEventListener('change', () => { 
                appState.layout.forceVertical = dom.verticalFieldChk.checked;
                LayoutManager.fitBoard();
            });

            // Menu/Sidebar
            dom.menuBtn.addEventListener('click', () => { dom.sidebar.classList.add('open'); dom.scrim.classList.add('show'); });
            dom.closeMenuBtn.addEventListener('click', () => { dom.sidebar.classList.remove('open'); dom.scrim.classList.remove('show'); });
            dom.scrim.addEventListener('click', () => { dom.sidebar.classList.remove('open'); dom.scrim.classList.remove('show'); });

            // Controles
            dom.resetBtn.addEventListener('click', () => { UnitsManager.createPlayers(); UnitsManager.placeBall(); DrawManager.clearDraw(); StorageManager.savePositions(); StorageManager.saveBall(); StorageManager.saveArrows(); StorageManager.saveStrokes(); });
            dom.snapToggle.addEventListener('change', () => { LayoutManager.renderGrid(); });
            dom.toggleLabelsBtn.addEventListener('click', (e) => {
                e.target.classList.toggle('active');
                e.target.textContent = e.target.classList.contains('active') ? 'Ocultar etichette' : 'Mostra etichette';
                [...dom.playersLayer.children].forEach(el => el.style.fontSize = e.target.classList.contains('active') ? 'var(--player-font)' : '0');
            });

            // Dibujo
            dom.toolArrowsBtn.addEventListener('click', () => DrawManager.setTool('arrows'));
            dom.toolPenBtn.addEventListener('click', () => DrawManager.setTool('pen'));
            dom.undoGenericBtn.addEventListener('click', DrawManager.undoLast);
            dom.clearArrowsBtn.addEventListener('click', DrawManager.clearArrows);
            dom.clearAllBtn.addEventListener('click', () => { if (confirm('¿Quieres eliminar todos los dibujos (frecce y líneas)?')) DrawManager.clearDraw(); });

            // Giocate/Plays
            dom.savePlayBtn.addEventListener('click', StorageManager.savePlay);
            dom.loadPlaySel.addEventListener('change', (e) => { if (e.target.value) StorageManager.loadPlay(e.target.value); });
            dom.deletePlayBtn.addEventListener('click', StorageManager.deletePlay);
            dom.duplicatePlayBtn.addEventListener('click', StorageManager.duplicatePlay);

            // Animación
            dom.recordStepBtn.addEventListener('click', TimelineManager.recordFrame);
            dom.scrubber.addEventListener('input', TimelineManager.handleScrubberChange);
            dom.scrubber.addEventListener('change', TimelineManager.handleScrubberChange);
            dom.prevFrameBtn.addEventListener('click', () => TimelineManager.loadFrame(Math.max(0, appState.playIndex - 1)));
            dom.nextFrameBtn.addEventListener('click', () => TimelineManager.loadFrame(Math.min(appState.timeline.length - 1, appState.playIndex + 1)));
            dom.playBtn.addEventListener('click', TimelineManager.startPlay);
            dom.pauseBtn.addEventListener('click', TimelineManager.pausePlay);
            dom.stopBtn.addEventListener('click', TimelineManager.stopPlay);
            dom.clearTimelineBtn.addEventListener('click', TimelineManager.clearTimeline);
            dom.exportTimelineBtn.addEventListener('click', StorageManager.exportTimeline);
            dom.importTimelineBtn.addEventListener('click', StorageManager.importTimeline);

            // Exportación
            ExportManager.setupExportUI();
        }
    };

    // ===== INIT =====
    function init(){
        LayoutManager.renderGrid(); 
        DrawManager.setTool('arrows');
        UnitsManager.createPlayers(); 
        StorageManager.loadPositions();
        StorageManager.loadArrows(); 
        StorageManager.loadStrokes(); 
        DrawManager.renderDraw();
        UnitsManager.placeBall(WIDTH/2, HEIGHT/2); 
        StorageManager.loadBall();
        StorageManager.loadTimeline(); 
        TimelineManager.updateScrubber();
        
        // Frame inicial automático si no hay timeline
        if (!Array.isArray(appState.timeline) || appState.timeline.length === 0) {
            TimelineManager.recordFrame();
            appState.playIndex = 0;
            TimelineManager.updateScrubber();
            StorageManager.saveTimeline();
        }
UIManager.setupEventListeners();
        DrawManager.enableDrawing();
        dom.draw.style.pointerEvents = 'auto';
        UnitsManager.enableDragBall(() => { StorageManager.saveBall(); if (dom.autoRecordChk.checked) TimelineManager.recordFrame(); });
        StorageManager.updatePlaySelect();
        LayoutManager.fitBoard(); // Ajuste inicial del layout
    }

    init();
  </script>
</body>
</html>
