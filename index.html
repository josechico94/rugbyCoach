<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>RugbyBoard Pro - Lavagna Tattica</title>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.min.js"></script>
    <style>
        :root {
            --sidebar-w: 360px;
            --player-size: 40px;
            --player-font: 14px;
            --blue: #0d6efd;
            --red: #e63946;
            --ink: #e6edf3;
            --panel: #0f1720;
            --panel-2: #111923;
            --border: #1f2a36;
            --shadow: 0 4px 16px rgba(0,0,0,.25);
            --grid: rgba(255,255,255,.08);
            --yellow: #ffd400;
            --accent: #00c2ff;
            --accent2: #7ef29a;
            --warn: #ffd400;
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; background: #0b1720; color: var(--ink); font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial,"Noto Sans",sans-serif; }
        .app { height: 100dvh; display: grid; grid-template-columns: var(--sidebar-w) 1fr; }

        .sidebar { background: var(--panel-2); border-right: 1px solid var(--border); padding: 16px; display: flex; flex-direction: column; gap: 12px; overflow: auto; z-index: 1000; -webkit-overflow-scrolling: touch; }
        .sidebar h1 { font-size: 18px; margin: 0 0 8px 0; }
        .group { border: 1px solid var(--border); background: var(--panel); border-radius: 12px; padding: 12px; display: grid; gap: 10px; }
        .group strong { font-size: 12px; text-transform: uppercase; letter-spacing: .06em; opacity: .9; }
        .row { display: grid; gap: 8px; }

        .btn, select, input[type="text"], input[type="number"], input[type="range"], label.chk {
            appearance: none; border: 1px solid #263443; background: #15202b; color: var(--ink);
            padding: .55rem .7rem; border-radius: 10px; box-shadow: var(--shadow); font-size: 14px;
        }
        .btn { cursor: pointer; text-align: center; }
        .btn:hover { filter: brightness(1.08); }
        .btn.alt { background: #0e2235; }
        .btn.primary { background: var(--accent); color: #000; font-weight: 600; }
        .btn.danger { background: var(--red); color: #fff; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn.active { background: var(--blue); border-color: var(--blue); }

        small.note { opacity:.8 }
        .legend { display:flex; align-items:center; gap:8px; font-size: 13px; }
        .swatch { width: .9em; height: .9em; border-radius: 50%; display:inline-block; }

        .stage { position: relative; display: grid; place-items: center; padding: 16px; overflow: hidden; }
        .board-viewport { position: relative; width:100%; height:100%; contain: layout paint; }
        .board-wrap { position: absolute; width: 1200px; height: 700px; transform-origin: top left; }
        .board { position: absolute; inset: 0; background: #137a46; overflow: hidden; border-radius: 18px; box-shadow: 0 10px 40px rgba(0,0,0,.4); }

        .board::before {
            content:""; position:absolute; inset:0; pointer-events:none;
            background-image: linear-gradient(90deg, rgba(255,255,255,.02) 0 5%, transparent 5% 10%, rgba(255,255,255,.02) 10% 15%, transparent 15% 20%, rgba(255,255,255,.02) 20% 25%, transparent 25% 30%, rgba(255,255,255,.02) 30% 35%, transparent 35% 40%, rgba(255,255,255,.02) 40% 45%, transparent 45% 50%, rgba(255,255,255,.02) 50% 55%, transparent 55% 60%, rgba(255,255,255,.02) 60% 65%, transparent 65% 70%, rgba(255,255,255,.02) 70% 75%, transparent 75% 80%, rgba(255,255,255,.02) 80% 85%, transparent 85% 90%, rgba(255,255,255,.02) 90% 95%, transparent 95% 100%);
        }
        .grid-overlay { position:absolute; inset:0; pointer-events:none; opacity:.6; display:none; }
        .grid-overlay.active { display:block; }

        /* Dejamos pointer-events:none en la capa draw por defecto para que la selecci√≥n funcione en el board. */
        .lines, #draw { position:absolute; inset:0; pointer-events:none; }
        svg { width:100%; height:100%; display:block; }

        body, #boardViewport, #boardWrap, #board, #players, #ball, #draw { touch-action:none; }

        #players { position:absolute; inset:0; z-index:3; pointer-events:none; }
        .player { pointer-events:auto; position:absolute; width:40px; height:40px; border-radius:50%; display:grid; place-items:center; font-weight:700; font-size:14px; color:#fff; cursor:grab; border:2px solid #fff; box-shadow: var(--shadow); }
        .player.selected { border: 3px solid var(--accent); box-shadow: 0 0 10px var(--accent); }
        .player:active, #ball:active { cursor: grabbing !important; }
        
        #ball { position:absolute; z-index:4; }
        .blue { background: var(--blue); } .red { background: var(--red); }

        .ball { width:50px; height:30px; background: var(--yellow); border: 2px solid #fff; border-radius: 50% / 60%; transform: translate(-50%,-50%) rotate(-15deg); box-shadow: 0 3px 12px rgba(0,0,0,.35); cursor: grab; }
        .ball::after { content:""; position:absolute; inset:6px 18px; border-radius:50% / 60%; border:2px dashed rgba(0,0,0,.25); }
        .label { font-size:12px; font-weight:700; fill:#fff; text-shadow: 0 1px 2px rgba(0,0,0,.6); }

        .hamburger { 
            position: fixed; 
            top: calc(12px + env(safe-area-inset-top)); 
            left: calc(12px + env(safe-area-inset-left)); 
            width: 44px; 
            height: 44px; 
            display: none; 
            place-items: center; 
            font-size: 22px; 
            border: 1px solid #263443; 
            background: #15202b; 
            color: var(--ink); 
            border-radius: 10px; 
            box-shadow: var(--shadow); 
            z-index: 1100; 
            cursor: pointer;
        }
        .close-drawer { 
            display: none; 
            position: sticky; 
            top: 0; 
            margin-left: auto; 
            width: 36px; 
            height: 36px; 
            border: 1px solid #263443; 
            background: #15202b; 
            color: var(--ink); 
            border-radius: 10px; 
            box-shadow: var(--shadow); 
            z-index: 1001; 
            cursor: pointer;
            place-items: center;
        }
        .scrim { 
            position: fixed; 
            inset: 0; 
            background: rgba(0,0,0,.45); 
            opacity: 0; 
            pointer-events: none; 
            transition: opacity .2s ease; 
            z-index: 900; 
        }
        .scrim.show { 
            opacity: 1; 
            pointer-events: auto; 
        }

        .login-overlay { 
            position: fixed; 
            inset: 0; 
            background: #0b1720; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            z-index: 3000; 
            padding: 20px;
        }
        .login-container {
            background: var(--panel);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            width: 100%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .login-header {
            text-align: center;
            margin-bottom: 1rem;
        }
        .login-header h1 {
            color: var(--accent);
            margin: 0 0 0.5rem 0;
            font-size: 1.5rem;
        }
        .login-header p {
            color: var(--ink);
            opacity: 0.8;
            margin: 0;
        }
        .login-input {
            width: 100%;
            padding: 12px;
            background: #0c1c2b;
            color: var(--ink);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 14px;
        }
        .login-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        .login-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent);
            color: #000;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
        }
        .login-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .login-message {
            text-align: center;
            font-size: 0.85rem;
            margin: 0;
            min-height: 20px;
        }
        .login-error {
            color: var(--red);
        }
        .login-success {
            color: var(--accent2);
        }

        .status-indicator { display: flex; align-items: center; gap: 8px; font-size: 12px; padding: 8px 12px; border-radius: 8px; background: var(--panel); border: 1px solid var(--border); }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent); }
        .status-dot.offline { background: var(--warn); }
        .status-dot.error { background: var(--red); }

        .player-counter {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            opacity: 0.8;
        }

        .firebase-status {
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            margin-top: 8px;
            display: none;
        }
        .firebase-status.connected {
            background: rgba(126, 242, 154, 0.1);
            border: 1px solid var(--accent2);
            color: var(--accent2);
            display: block;
        }
        .firebase-status.disconnected {
            background: rgba(230, 57, 70, 0.1);
            border: 1px solid var(--red);
            color: var(--red);
            display: block;
        }

        .success-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--accent2);
            color: #000;
            padding: 16px 20px;
            border-radius: 10px;
            box-shadow: var(--shadow);
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }
        .success-popup.show {
            transform: translateX(0);
        }
        .success-popup.hide {
            transform: translateX(400px);
        }

        .btn.selection-tool {
            background: var(--blue);
            border-color: var(--blue);
        }

        @media (max-width: 900px) {
            :root { --sidebar-w: min(86vw, 420px); }
            html, body { overflow: hidden; height: 100dvh; }
            .app { grid-template-columns: 1fr; height: 100dvh; }
            .sidebar { 
                position: fixed; 
                top: 0; 
                left: 0; 
                bottom: 0; 
                width: var(--sidebar-w); 
                transform: translateX(-105%); 
                transition: transform .25s ease; 
                padding-top: calc(12px + env(safe-area-inset-top)); 
                z-index: 1000;
            }
            .sidebar.open { transform: translateX(0); }
            .close-drawer { display: grid; }
            .hamburger { display: grid; }
            .stage { padding: 0; }
            .board-viewport { 
                position: fixed; 
                top: 0; 
                left: 0; 
                right: 0; 
                bottom: 0; 
                overflow: hidden; 
                background: #0b1720;
            }
        }

        @media (max-width: 900px) {
            .hamburger {
                display: grid !important;
            }
            
            .main-app-visible .hamburger {
                display: grid !important;
            }
        }
    </style>
</head>
<body>
    <div class="login-overlay" id="loginOverlay">
        <div class="login-container">
            <div class="login-header">
                <h1>RugbyBoard Pro</h1>
                <p>Accedi per utilizzare la lavagna</p>
            </div>
            <input type="email" id="loginEmail" class="login-input" placeholder="Email" />
            <input type="password" id="loginPassword" class="login-input" placeholder="Password" />
            <button class="login-btn" id="btnLogin">Accedi</button>
            <p id="loginMessage" class="login-message"></p>
        </div>
    </div>

    <div id="successPopup" class="success-popup">
        <span>‚úÖ</span>
        <span id="successMessage">Giocata salvata correttamente!</span>
    </div>

    <button id="menuBtn" class="hamburger" aria-label="Apri pannello">‚ò∞</button>
    <div id="scrim" class="scrim" aria-hidden="true"></div>

    <div class="app" style="display: none;" id="mainApp">
        <aside class="sidebar" id="sidebar">
            <button id="closeMenu" class="close-drawer" aria-label="Chiudi">‚úï</button>
            
            <div class="group">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h1>RugbyBoard Pro</h1>
                    <div class="status-indicator" id="authStatus">
                        <span class="status-dot" id="statusDot"></span>
                        <span id="statusText">Conectando...</span>
                    </div>
                </div>
                
                <div id="firebaseStatus" class="firebase-status disconnected">
                    ‚ö†Ô∏è Configura le regole di sicurezza in Firebase Console
                </div>
                
                <button class="btn primary" id="btnAuthAction">Esci</button>
            </div>

            <div class="group">
                <strong>Controlli</strong>
                <div class="row" style="grid-template-columns: 1fr;">
                    <button class="btn" id="toggleLabels">Mostra etichette</button>
                    <button class="btn alt" id="reset">Reimposta posizioni</button>
                </div>
                <label class="chk" style="display:flex;align-items:center;gap:8px;border:none;background:transparent;padding:0;box-shadow:none">
                    <input type="checkbox" id="snapToggle"> Aggancia alla griglia
                </label>
                <label class="chk" style="display:flex;align-items:center;gap:8px;border:none;background:transparent;padding:0;box-shadow:none">
                    <input type="checkbox" id="verticalField"> Campo vertical
                </label>
                
               <div class="player-counter">
                    <span>Jugadores: <span id="playerCount">0</span>/30</span>
                    <span style="font-size: 11px; opacity: 0.7;">(15 blu + 15 rossi)</span>
                    <button class="btn alt" id="addPlayerBtn" style="margin-left: auto;">+ Aggiungi Giocatore</button>
                </div>
                
                <div class="legend"><span class="swatch" style="background:#0d6efd"></span> Blu (1‚Äì15)</div>
                <div class="legend"><span class="swatch" style="background:#e63946"></span> Rossi (1‚Äì15)</div>
            </div>

            <div class="group">
                <strong>Strumenti</strong>
                <div class="row" style="grid-template-columns: 1fr 1fr 1fr;">
                    <button class="btn selection-tool active" id="toolSelect">Selezione</button>
                    <button class="btn alt" id="toolArrows">Frecce</button>
                    <button class="btn alt" id="toolPen">Matita</button>
                </div>
                <div class="row" style="grid-template-columns: 1fr 1fr;">
                    <label>Colore
                        <select id="strokeColor">
                            <option value="#ffffff">Bianco</option>
                            <option value="#35d07f">Verde</option>
                            <option value="#0d6efd">Blu</option>
                            <option value="#e63946">Rosso</option>
                            <option value="#f4d35e" selected>Giallo</option>
                        </select>
                    </label>
                    <label>Spessore
                        <select id="strokeWidth">
                            <option value="3">Sottile</option>
                            <option value="5" selected>Medio</option>
                            <option value="7">Grosso</option>
                        </select>
                    </label>
                </div>
                <label class="chk" style="border:none;background:transparent;padding:0;box-shadow:none">
                    <input type="checkbox" id="dashedToggle"> Linea tratteggiada
                </label>
                <div class="row" style="grid-template-columns: 1fr 1fr;">
                    <button class="btn" id="undoGeneric">Annulla</button>
                    <button class="btn" id="clearArrows">Cancella frecce</button>
                </div>
                <button class="btn" id="clearAll">Cancella tutto</button>
            </div>

            <div class="group">
                <strong>Giocate</strong>
                <input type="text" id="playName" placeholder="Nome giocata" />
                <div class="row" style="grid-template-columns: 1fr 1fr;">
                    <button class="btn" id="savePlay">Salva</button>
                    <button class="btn alt" id="duplicatePlay">Duplica</button>
                </div>
                <select id="loadPlay"></select>
                <div class="row" style="grid-template-columns: 1fr 1fr;">
                    <button class="btn danger" id="deletePlay">Elimina</button>
                    <button class="btn" id="btnLoadPlay">Carica</button>
                </div>
            </div>

            <div class="group">
                <strong>Animazione</strong>
                <div class="row" style="grid-template-columns: 1fr 1fr; gap:8px;">
                    <button class="btn" id="recordStepBtn">Registra passo</button>
                    <label class="chk" style="display:flex;align-items:center;gap:8px;border:none;background:transparent;padding:.4rem .6rem;box-shadow:none">
                        <input type="checkbox" id="autoRecord"> Auto al rilascio
                    </label>
                </div>

                <div class="row" style="grid-template-columns: 1fr 1fr 1fr; gap:8px;">
                    <button class="btn primary" id="playBtn">Play</button>
                    <button class="btn alt" id="pauseBtn">Pause</button>
                    <button class="btn" id="stopBtn">Stop</button>
                </div>

                <div class="row" style="grid-template-columns: auto 1fr; align-items:center;">
                    Velocidad (ms por paso)
                    <input type="number" id="speedInput" min="100" step="100" value="800" />
                </div>

                <div class="row" style="grid-template-columns: 1fr; gap:8px;">
                    <label>Scrubber (0 ‚Üí N)
                        <input type="range" id="scrubber" min="0" max="0" value="0" />
                    </label>
                    <div style="display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;">
                        <button class="btn alt" id="prevFrameBtn">‚óÄ Precedente</button>
                        <div style="text-align:center;">Frame: <span id="scrubberVal">0</span> / <span id="frameTotal">0</span></div>
                        <button class="btn alt" id="nextFrameBtn">Successivo ‚ñ∂</button>
                    </div>
                </div>

                <div class="row" style="grid-template-columns: 1fr 1fr; gap:8px;">
                    <button class="btn alt" id="clearTimelineBtn">Pulisci</button>
                    <button class="btn" id="exportTimelineBtn">Expor JSON</button>
                </div>
                <button class="btn alt" id="importTimelineBtn">Import JSON</button>
                <div style="font-size:12px;opacity:.8;">Frames salvati: <span id="frameCount">0</span></div>
            </div>

            <div class="group">
                <strong>Export</strong>
                <div class="row" style="grid-template-columns: 1fr;">
                    <button class="btn" id="exportJpgBtn">Export immagine (JPG)</button>
                    <button class="btn alt" id="exportVideoBtn">Export video (WebM)</button>
                    <button class="btn" id="exportMp4Btn">Export MP4 (beta)</button>
                    <small class="note">El video incluye jugadores, pallone, flechas y l√≠neas. MP4 usa ffmpeg.wasm (puede tardar la 1¬™ vez).</small>
                    <div id="ffmpegStatus" class="note"></div>
                </div>
            </div>

            <div class="group">
                <strong>Debug</strong>
                <button class="btn" onclick="testFirebaseDebug()">üîß Test Firebase</button>
                <button class="btn alt" onclick="showFirebaseStatus()">üìä Estado Firebase</button>
                <button class="btn" onclick="diagnoseFirebaseIssue()">üîç Diagnosticar</button>
                <button class="btn alt" onclick="fixFirebaseConnection()">üîÑ Reconectar</button>
            </div>
        </aside>

        <main class="stage">
            <div class="board-viewport" id="boardViewport">
                <div class="board-wrap" id="boardWrap">
                    <div id="board" class="board">
                        <svg class="grid-overlay" id="grid" viewBox="0 0 1200 700" preserveAspectRatio="none"></svg>

                        <svg class="lines" viewBox="0 0 1200 700" preserveAspectRatio="none" aria-hidden="true">
                            <rect x="5" y="5" width="1190" height="690" fill="none" stroke="#fff" stroke-width="6" />
                            <rect x="0" y="0" width="80" height="700" fill="rgba(255,255,255,.07)" />
                            <rect x="1120" y="0" width="80" height="700" fill="rgba(255,255,255,.07)" />
                            <line x1="80" y1="0" x2="80" y2="700" stroke="#fff" stroke-width="4" />
                            <line x1="1120" y1="0" x2="1120" y2="700" stroke="#fff" stroke-width="4" />
                            <line x1="309" y1="0" x2="309" y2="700" stroke="#fff" stroke-width="3" />
                            <line x1="891" y1="0" x2="891" y2="700" stroke="#fff" stroke-width="3" />
                            <line x1="500" y1="0" x2="500" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10" />
                            <line x1="697" y1="0" x2="697" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10" />
                            <line x1="600" y1="0" x2="600" y2="700" stroke="#fff" stroke-width="4" />
                            <line x1="5" y1="50" x2="1195" y2="50" stroke="#fff" stroke-width="2" stroke-dasharray="4 8" />
                            <line x1="5" y1="150" x2="1195" y2="150" stroke="#fff" stroke-width="2" stroke-dasharray="4 8" />
                            <line x1="5" y1="550" x2="1195" y2="550" stroke="#fff" stroke-width="2" stroke-dasharray="4 8" />
                            <line x1="5" y1="650" x2="1195" y2="650" stroke="#fff" stroke-width="2" stroke-dasharray="4 8" />
                            <line x1="130" y1="0" x2="130" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10"/>
                            <line x1="1070" y1="0" x2="1070" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10"/>
                        </svg>

                        <svg id="draw" viewBox="0 0 1200 700" preserveAspectRatio="none"></svg>
                        <div id="players"></div>
                        <div id="ball" class="ball" title="Pallone"></div>
                        <div id="selectionBox" style="position:absolute; pointer-events:none; border:1px dashed var(--accent); background:rgba(0,194,255,0.1); z-index:5; display:none;"></div>
                    </div>
                </div>
            </div>
            <canvas id="exportCanvas" width="1200" height="700" style="position:fixed; top:-9999px; left:-9999px;"></canvas>
        </main>
    </div>

    <script type="module">
        // --- IMPORTS FIREBASE ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, deleteDoc, collection, query, onSnapshot, getDoc, getDocs, where, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURACI√ìN FIREBASE ---
        const firebaseConfig = {
            apiKey: "AIzaSyACU3QfuTpW6PNRt3hHl9m1dy4Vso0GPoI",
            authDomain: "bologna-rugby-club.firebaseapp.com",
            projectId: "bologna-rugby-club",
            storageBucket: "bologna-rugby-club.firebasestorage.app",
            messagingSenderId: "641438144435",
            appId: "1:641438144435:web:e2a243bacd522fd1615dc6",
            measurementId: "G-9C66KXJ561"
        };

        // Variables globales Firebase
        let app, db = null, auth;
        let isAuthorized = false;
        let currentUser = null;
        let firebaseConnected = false;

        // --- CONSTANTES GLOBALES ---
        const WIDTH = 1200, HEIGHT = 700;
        const GRID_SIZE = 24;
        const TL_KEY = 'rugby-timeline-v2';
        const POS_KEY = 'rugby-positions-v3';
        const ARROW_KEY = 'rugby-arrows-v3';
        const STROKE_KEY = 'rugby-strokes-v1';
        const BALL_KEY = 'rugby-ball-v1';
        const PLAY_PREFIX = 'play-v3-';

        // --- ESTADO CENTRALIZADO (appState) ---
        let appState = {
            layout: { mode: 'landscape', scale: 1, tx: 0, ty: 0, forceVertical: false },
            tool: 'select',
            arrows: [],
            strokes: [],
            drawingArrow: false,
            drawingStroke: false,
            startPoint: null,
            currentStroke: null,
            timeline: [],
            playing: false,
            paused: false,
            playIndex: 0,
            rafId: null,
            segmentStartTime: 0,
            segmentDuration: 800,
            fromFrame: null,
            toFrame: null,
            selectedPlayers: new Set(),
            playerCounter: { blue: 0, red: 0 }
        };

        // --- REFERENCIAS DEL DOM ---
        const dom = {
            loginOverlay: document.getElementById('loginOverlay'),
            mainApp: document.getElementById('mainApp'),
            boardViewport: document.getElementById('boardViewport'),
            boardWrap: document.getElementById('boardWrap'),
            board: document.getElementById('board'),
            playersLayer: document.getElementById('players'),
            draw: document.getElementById('draw'),
            gridSvg: document.getElementById('grid'),
            ball: document.getElementById('ball'),
            exportCanvas: document.getElementById('exportCanvas'),
            ctx: document.getElementById('exportCanvas').getContext('2d'),
            selectionBox: document.getElementById('selectionBox'),
            sidebar: document.getElementById('sidebar'),
            menuBtn: document.getElementById('menuBtn'),
            closeMenuBtn: document.getElementById('closeMenu'),
            scrim: document.getElementById('scrim'),
            loginEmail: document.getElementById('loginEmail'),
            loginPassword: document.getElementById('loginPassword'),
            btnLogin: document.getElementById('btnLogin'),
            loginMessage: document.getElementById('loginMessage'),
            btnAuthAction: document.getElementById('btnAuthAction'),
            authStatus: document.getElementById('authStatus'),
            statusDot: document.getElementById('statusDot'),
            statusText: document.getElementById('statusText'),
            toggleLabelsBtn: document.getElementById('toggleLabels'),
            resetBtn: document.getElementById('reset'),
            snapToggle: document.getElementById('snapToggle'),
            verticalFieldChk: document.getElementById('verticalField'),
            toolSelectBtn: document.getElementById('toolSelect'),
            toolArrowsBtn: document.getElementById('toolArrows'),
            toolPenBtn: document.getElementById('toolPen'),
            undoGenericBtn: document.getElementById('undoGeneric'),
            clearArrowsBtn: document.getElementById('clearArrows'),
            clearAllBtn: document.getElementById('clearAll'),
            strokeColorSel: document.getElementById('strokeColor'),
            strokeWidthSel: document.getElementById('strokeWidth'),
            dashedToggle: document.getElementById('dashedToggle'),
            recordStepBtn: document.getElementById('recordStepBtn'),
            autoRecordChk: document.getElementById('autoRecord'),
            playBtn: document.getElementById('playBtn'),
            pauseBtn: document.getElementById('pauseBtn'),
            stopBtn: document.getElementById('stopBtn'),
            speedInput: document.getElementById('speedInput'),
            clearTimelineBtn: document.getElementById('clearTimelineBtn'),
            exportTimelineBtn: document.getElementById('exportTimelineBtn'),
            importTimelineBtn: document.getElementById('importTimelineBtn'),
            frameCountEl: document.getElementById('frameCount'),
            scrubber: document.getElementById('scrubber'),
            scrubberVal: document.getElementById('scrubberVal'),
            frameTotal: document.getElementById('frameTotal'),
            prevFrameBtn: document.getElementById('prevFrameBtn'),
            nextFrameBtn: document.getElementById('nextFrameBtn'),
            playNameInput: document.getElementById('playName'),
            loadPlaySel: document.getElementById('loadPlay'),
            savePlayBtn: document.getElementById('savePlay'),
            duplicatePlayBtn: document.getElementById('duplicatePlay'),
            deletePlayBtn: document.getElementById('deletePlay'),
            btnLoadPlay: document.getElementById('btnLoadPlay'),
            exportJpgBtn: document.getElementById('exportJpgBtn'),
            exportVideoBtn: document.getElementById('exportVideoBtn'),
            exportMp4Btn: document.getElementById('exportMp4Btn'),
            ffmpegStatus: document.getElementById('ffmpegStatus'),
            playerCount: document.getElementById('playerCount'),
            addPlayerBtn: document.getElementById('addPlayerBtn'),
            firebaseStatus: document.getElementById('firebaseStatus'),
            successPopup: document.getElementById('successPopup'),
            successMessage: document.getElementById('successMessage')
        };

        // --- SISTEMA DE AUTENTICACI√ìN ---
        const AuthManager = {
            async init() {
                try {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    
                    console.log('‚úÖ Firebase inicializado correctamente');
                    
                    onAuthStateChanged(auth, async (user) => {
                        currentUser = user;
                        if (user) {
                            isAuthorized = true;
                            AuthManager.showApp();
                            AuthManager.updateUI(true);
                            AuthManager.showStatus(`¬°Bienvenido ${user.email}! Modo Entrenador`, 'success');
                            
                            console.log('üîê Usuario autenticado, probando conexi√≥n Firebase...');
                            await AuthManager.testFirebaseConnection();
                            
                            InteractionManager.enableSelectionBox();
                            InteractionManager.reinitializePlayerInteractions();
                            UnitsManager.enableDragBall(() => { 
                                StorageManager.saveBall(); 
                                if (dom.autoRecordChk.checked) TimelineManager.recordFrame(); 
                            });
                            
                            StorageManager.updatePlaySelect();
                        } else {
                            isAuthorized = false;
                            firebaseConnected = false;
                            AuthManager.showLogin();
                            AuthManager.updateUI(false);
                        }
                    });
                    
                } catch (error) {
                    console.error("Firebase fall√≥:", error);
                    AuthManager.showLogin();
                    AuthManager.showStatus('Error de conexi√≥n. Intenta m√°s tarde.', 'error');
                    AuthManager.updateFirebaseStatus(false);
                }
            },

            async testFirebaseConnection() {
                try {
                    const user = auth.currentUser;
                    if (!user) {
                        console.log('üî¥ No hay usuario para probar conexi√≥n');
                        return false;
                    }

                    console.log('üîÑ Probando conexi√≥n Firebase completa...');
                    
                    const testQuery = query(collection(db, "users", user.uid, "plays"));
                    const querySnapshot = await getDocs(testQuery);
                    
                    console.log('‚úÖ Conexi√≥n Firebase exitosa');
                    
                    firebaseConnected = true;
                    AuthManager.updateFirebaseStatus(true);
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå Error en conexi√≥n Firebase:', error);
                    firebaseConnected = false;
                    AuthManager.updateFirebaseStatus(false, error);
                    return false;
                }
            },

            updateFirebaseStatus(connected, error = null) {
                firebaseConnected = connected;
                if (connected) {
                    dom.firebaseStatus.textContent = '‚úÖ Firebase: Connesso e funzionante';
                    dom.firebaseStatus.className = 'firebase-status connected';
                } else {
                    let errorMessage = '‚ö†Ô∏è Problema de conexi√≥n con Firebase';
                    if (error) {
                        errorMessage += ` - ${error.code || 'Error desconocido'}`;
                    }
                    dom.firebaseStatus.innerHTML = `
                        ${errorMessage}<br>
                        <small>Verifica las reglas de seguridad en Firebase Console</small>
                    `;
                    dom.firebaseStatus.className = 'firebase-status disconnected';
                }
            },

            showLogin() {
                dom.loginOverlay.style.display = 'flex';
                dom.mainApp.style.display = 'none';
                dom.menuBtn.style.display = 'none';
            },

            showApp() {
                dom.loginOverlay.style.display = 'none';
                dom.mainApp.style.display = 'grid';
                if (window.innerWidth <= 900) {
                    dom.menuBtn.style.display = 'grid';
                }
                document.body.classList.add('main-app-visible');
            },

            updateUI(isLoggedIn) {
                if (isLoggedIn && currentUser) {
                    dom.btnAuthAction.style.display = 'block';
                    dom.btnAuthAction.textContent = 'Esci';
                    dom.statusDot.className = 'status-dot';
                    dom.statusText.textContent = currentUser.email;
                    AuthManager.setControlsEnabled(true);
                } else {
                    dom.btnAuthAction.style.display = 'none';
                    dom.statusDot.className = 'status-dot error';
                    dom.statusText.textContent = 'No autenticado';
                    AuthManager.setControlsEnabled(false);
                }
            },

            setControlsEnabled(enabled) {
                const controls = [
                    dom.resetBtn, dom.toolSelectBtn, dom.toolArrowsBtn, dom.toolPenBtn, dom.undoGenericBtn,
                    dom.clearArrowsBtn, dom.clearAllBtn, dom.recordStepBtn, dom.savePlayBtn,
                    dom.duplicatePlayBtn, dom.deletePlayBtn, dom.btnLoadPlay, dom.addPlayerBtn
                ];
                
                controls.forEach(control => {
                    if (control) control.disabled = !enabled;
                });
                
                if (dom.strokeColorSel) dom.strokeColorSel.disabled = !enabled;
                if (dom.strokeWidthSel) dom.strokeWidthSel.disabled = !enabled;
                if (dom.dashedToggle) dom.dashedToggle.disabled = !enabled;
            },

            async login() {
                const email = dom.loginEmail.value;
                const password = dom.loginPassword.value;
                
                if (!email || !password) {
                    AuthManager.showMessage("Ingresa email y contrase√±a.", 'error');
                    return;
                }
                
                dom.btnLogin.disabled = true;
                AuthManager.showMessage("Iniciando sesi√≥n...", 'info');
                
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    AuthManager.showMessage("", 'success');
                } catch (error) {
                    let message = "Credenciales incorrectas.";
                    if (error.code === 'auth/invalid-email') message = "Formato de email inv√°lido.";
                    if (error.code === 'auth/user-not-found') message = "Usuario no encontrado.";
                    if (error.code === 'auth/wrong-password') message = "Contrase√±a incorrecta.";
                    if (error.code === 'auth/too-many-requests') message = "Demasiados intentos. Intenta m√°s tarde.";
                    
                    AuthManager.showMessage(`Error: ${message}`, 'error');
                } finally {
                    dom.btnLogin.disabled = false;
                }
            },

            async logout() {
                try {
                    await signOut(auth);
                    AuthManager.showMessage('Sesi√≥n cerrada', 'info');
                    AuthManager.showLogin();
                } catch (error) {
                    console.error("Error al cerrar sesi√≥n:", error);
                    AuthManager.showMessage('Error al cerrar sesi√≥n', 'error');
                }
            },

            showMessage(message, type = 'info') {
                dom.loginMessage.textContent = message;
                dom.loginMessage.className = 'login-message';
                if (type === 'error') dom.loginMessage.classList.add('login-error');
                if (type === 'success') dom.loginMessage.classList.add('login-success');
            },

            showStatus(message, type = 'info') {
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
        };

        // --- UTILIDADES ---
        function dist(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return Math.hypot(dx, dy); }
        function centerOf(el) { return { x: parseFloat(el.style.left) || 0, y: parseFloat(el.style.top) || 0 }; }
        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
        function lerp(a, b, t) { return a + (b - a) * t; }
        function ballOverPlayer(playerEl, threshold = 28) {
            const b = centerOf(dom.ball);
            const p = centerOf(playerEl);
            return dist(b.x, b.y, p.x, p.y) < threshold;
        }
        function snap(val) { return Math.round(val / GRID_SIZE) * GRID_SIZE; }

        // --- SISTEMA DE POPUP DE √âXITO ---
        const PopupManager = {
            showSuccess(message) {
                dom.successMessage.textContent = message;
                dom.successPopup.classList.remove('hide');
                dom.successPopup.classList.add('show');
                
                setTimeout(() => {
                    PopupManager.hideSuccess();
                }, 3000);
            },
            
            hideSuccess() {
                dom.successPopup.classList.remove('show');
                dom.successPopup.classList.add('hide');
            }
        };

        // --- GESTI√ìN DE LAYOUT Y COORDENADAS ---
        const LayoutManager = {
            isPortraitLike() {
                if (appState.layout.forceVertical) return true;
                const mq = window.matchMedia('(orientation: portrait)');
                return (mq && mq.matches) || (window.innerHeight > window.innerWidth);
            },
            applyUprightTransforms() {
                const rotatePlayers = (appState.layout.mode === 'portrait');
                [...dom.playersLayer.children].forEach(el => {
                    el.style.transform = rotatePlayers
                        ? 'translate(-50%, -50%) rotate(-90deg)'
                        : 'translate(-50%, -50%)';
                });
            },
            fitBoard() {
                const vp = dom.boardViewport.getBoundingClientRect();
                const availW = vp.width;
                const availH = vp.height;

                if (!LayoutManager.isPortraitLike()) {
                    appState.layout.mode = 'landscape';
                    appState.layout.scale = Math.min(availW / WIDTH, availH / HEIGHT);
                    
                    const scaledW = WIDTH * appState.layout.scale;
                    const scaledH = HEIGHT * appState.layout.scale;
                    appState.layout.tx = (availW - scaledW) / 2;
                    appState.layout.ty = (availH - scaledH) / 2;
                    
                    dom.boardWrap.style.transform = `translate(${appState.layout.tx}px, ${appState.layout.ty}px) rotate(0deg) scale(${appState.layout.scale})`;
                    dom.boardWrap.style.transformOrigin = 'top left';

                } else {
                    appState.layout.mode = 'portrait';
                    const rotW = HEIGHT;
                    const rotH = WIDTH;

                    appState.layout.scale = Math.min(availW / rotW, availH / rotH);
                    
                    const contentW = rotW * appState.layout.scale;
                    const contentH = rotH * appState.layout.scale;
                    
                    const txCenter = (availW - contentW) / 2;
                    const tyCenter = (availH - contentH) / 2;
                    
                    appState.layout.tx = txCenter + contentW;
                    appState.layout.ty = tyCenter;

                    dom.boardWrap.style.transform = `translate(${appState.layout.tx}px, ${appState.layout.ty}px) rotate(90deg) scale(${appState.layout.scale})`;
                    dom.boardWrap.style.transformOrigin = 'top left';
                }
                
                LayoutManager.applyUprightTransforms();
            },
            clientToBoard(e) {
                const vp = dom.boardViewport.getBoundingClientRect();
                const cx = e.clientX - vp.left;
                const cy = e.clientY - vp.top;
                if (appState.layout.mode === 'portrait') {
                    const x_raw = (cx - appState.layout.tx);
                    const y_raw = (cy - appState.layout.ty);

                    const px = y_raw / appState.layout.scale;
                    const py = -x_raw / appState.layout.scale;
                    
                    const x = px;
                    const y = py;
                    
                    return { x: clamp(x, 0, WIDTH), y: clamp(y, 0, HEIGHT) };
                } else {
                    const x = (e.clientX - vp.left - appState.layout.tx) / appState.layout.scale;
                    const y = (e.clientY - vp.top - appState.layout.ty) / appState.layout.scale;
                    return { x: clamp(x, 0, WIDTH), y: clamp(y, 0, HEIGHT) };
                }
            },
            deltaToBoard(dxClient, dyClient) {
                if (appState.layout.mode === 'portrait') {
                    const dx = dyClient / appState.layout.scale;
                    const dy = -dxClient / appState.layout.scale;
                    return { dx, dy };
                } else {
                    const rect = dom.board.getBoundingClientRect();
                    const scale = rect.width / WIDTH;
                    return { dx: dxClient / scale, dy: dyClient / scale };
                }
            },
            renderGrid() {
                const s = GRID_SIZE;
                dom.gridSvg.innerHTML = '';
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                for (let x = s; x < WIDTH; x += s) {
                    const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    l.setAttribute('x1', x); l.setAttribute('y1', 0); l.setAttribute('x2', x); l.setAttribute('y2', HEIGHT);
                    l.setAttribute('stroke', 'var(--grid)'); l.setAttribute('stroke-width', '1'); g.appendChild(l);
                }
                for (let y = s; y < HEIGHT; y += s) {
                    const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    l.setAttribute('x1', 0); l.setAttribute('y1', y); l.setAttribute('x2', WIDTH); l.setAttribute('y2', y);
                    l.setAttribute('stroke', 'var(--grid)'); l.setAttribute('stroke-width', '1'); g.appendChild(l);
                }
                dom.gridSvg.appendChild(g);
                dom.gridSvg.classList.toggle('active', dom.snapToggle.checked);
            }
        };

        // --- GESTI√ìN DE JUGADORES Y BAL√ìN ---
        const UnitsManager = {
            initialPositions: (function () {
                const positions = [];
                for (let i = 1; i <= 15; i++) positions.push({ team: 'blue', number: i, x: WIDTH * 0.18, y: HEIGHT * (0.1 + (i - 1) * (0.8 / 14)) });
                for (let i = 1; i <= 15; i++) positions.push({ team: 'red', number: i, x: WIDTH * 0.82, y: HEIGHT * (0.1 + (i - 1) * (0.8 / 14)) });
                return positions;
            })(),
            
            countPlayers() {
                const players = [...dom.playersLayer.children];
                const blueCount = players.filter(p => p.dataset.team === 'blue').length;
                const redCount = players.filter(p => p.dataset.team === 'red').length;
                appState.playerCounter.blue = blueCount;
                appState.playerCounter.red = redCount;
                const total = blueCount + redCount;
                dom.playerCount.textContent = total;
                
                dom.addPlayerBtn.disabled = total >= 30;
                dom.addPlayerBtn.textContent = total >= 30 ? 'Massimo 15 giocatori' : '+ Aggiungi Giocatore';
                
                return { blue: blueCount, red: redCount, total };
            },
            
            addPlayer() {
                const counts = this.countPlayers();
                if (counts.total >= 30) { 
                    alert('Massimo 30 giocatori raggiunto! (15 blu + 15 rossi)');
                    return null;
                }
                
                const team = counts.blue <= counts.red ? 'blue' : 'red';
                const newNumber = counts[team] + 1;
                const x = team === 'blue' ? WIDTH * 0.18 : WIDTH * 0.82;
                const y = HEIGHT * 0.5;
                
                const playerEl = this.createPlayerElement(team, newNumber, x, y);
                dom.playersLayer.appendChild(playerEl);
                
                this.countPlayers();
                StorageManager.savePositions();
                
                return playerEl;
            },
            
            createPlayerElement(team, number, x, y) {
                const el = document.createElement('div');
                el.className = `player ${team}`;
                el.textContent = number;
                el.style.left = x + 'px';
                el.style.top = y + 'px';
                el.dataset.number = number;
                el.dataset.team = team;
                
                this.enableDragPlayer(el, () => { 
                    StorageManager.savePositions(); 
                    if (dom.autoRecordChk.checked) TimelineManager.recordFrame(); 
                });
                
                return el;
            },
            
            createPlayers() {
                dom.playersLayer.innerHTML = '';
                this.initialPositions.forEach(p => {
                    dom.playersLayer.appendChild(this.createPlayerElement(p.team, p.number, p.x, p.y)); 
                });
                this.countPlayers();
                LayoutManager.applyUprightTransforms();
            },
            
            enableDragPlayer(playerEl, onDrop) {
                if (!isAuthorized) return;
                
                let pointerId = null, startX = 0, startY = 0, origL = 0, origT = 0;
                let lockBallToPlayer = false;
                let offX = 0, offY = 0;
                let isGroupMove = false;
                let playerOffsets = [];
                let isDragging = false; 

                const onDown = e => {
                    if (appState.tool !== 'select') return;
                    
                    pointerId = e.pointerId;
                    playerEl.setPointerCapture(pointerId);
                    e.preventDefault();
                    startX = e.clientX; startY = e.clientY;
                    origL = parseFloat(playerEl.style.left) || 0;
                    origT = parseFloat(playerEl.style.top) || 0;
                    isDragging = false;

                    // L√≥gica de selecci√≥n
                    if (e.ctrlKey || e.shiftKey) {
                        if (playerEl.classList.contains('selected')) {
                            playerEl.classList.remove('selected');
                            appState.selectedPlayers.delete(playerEl);
                        } else {
                            playerEl.classList.add('selected');
                            appState.selectedPlayers.add(playerEl);
                        }
                    } else if (!playerEl.classList.contains('selected')) {
                        InteractionManager.clearSelection();
                        playerEl.classList.add('selected');
                        appState.selectedPlayers.add(playerEl);
                    }

                    isGroupMove = appState.selectedPlayers.size > 1;
                    if (isGroupMove) {
                        playerOffsets = Array.from(appState.selectedPlayers).map(el => ({
                            el,
                            initialX: parseFloat(el.style.left),
                            initialY: parseFloat(el.style.top)
                        }));
                    }

                    lockBallToPlayer = ballOverPlayer(playerEl);
                    if (lockBallToPlayer) {
                        const p0 = { x: origL, y: origT };
                        const b0 = centerOf(dom.ball);
                        offX = b0.x - p0.x;
                        offY = b0.y - p0.y;
                    }

                    const onMove = ev => {
                        if (ev.pointerId !== pointerId) return;
                        ev.preventDefault();
                        isDragging = true;
                        const { dx, dy } = LayoutManager.deltaToBoard(ev.clientX - startX, ev.clientY - startY);
                        
                        if (isGroupMove) {
                            playerOffsets.forEach(pl => {
                                pl.el.style.left = clamp(pl.initialX + dx, 0, WIDTH) + 'px';
                                pl.el.style.top = clamp(pl.initialY + dy, 0, HEIGHT) + 'px';
                            });
                        } else {
                            playerEl.style.left = clamp(origL + dx, 0, WIDTH) + 'px';
                            playerEl.style.top = clamp(origT + dy, 0, HEIGHT) + 'px';
                        }

                        if (lockBallToPlayer) {
                            const newPlayerPos = centerOf(playerEl);
                            const bx = clamp(newPlayerPos.x + offX, 0, WIDTH);
                            const by = clamp(newPlayerPos.y + offY, 0, HEIGHT);
                            dom.ball.style.left = bx + 'px';
                            dom.ball.style.top = by + 'px';
                        }
                    };

                    const onUp = ev => {
                        if (ev.pointerId !== pointerId) return;
                        try { playerEl.releasePointerCapture(pointerId); } catch { }
                        document.removeEventListener('pointermove', onMove);
                        document.removeEventListener('pointerup', onUp);

                        if (isDragging) { 
                            if (dom.snapToggle.checked) {
                                const finalizePosition = (el) => {
                                    const px = snap(parseFloat(el.style.left));
                                    const py = snap(parseFloat(el.style.top));
                                    el.style.left = px + 'px';
                                    el.style.top = py + 'px';
                                    return { x: px, y: py };
                                };

                                if (isGroupMove) {
                                    playerOffsets.forEach(pl => finalizePosition(pl.el));
                                    if (lockBallToPlayer) {
                                        const playerPos = centerOf(playerEl);
                                        const sbx = clamp(snap(playerPos.x + offX), 0, WIDTH);
                                        const sby = clamp(snap(playerPos.y + offY), 0, HEIGHT);
                                        dom.ball.style.left = sbx + 'px';
                                        dom.ball.style.top = sby + 'px';
                                    }
                                } else {
                                    finalizePosition(playerEl);
                                    if (lockBallToPlayer) {
                                        const playerPos = centerOf(playerEl);
                                        const sbx = clamp(snap(playerPos.x + offX), 0, WIDTH);
                                        const sby = clamp(snap(playerPos.y + offY), 0, HEIGHT);
                                        dom.ball.style.left = sbx + 'px';
                                        dom.ball.style.top = sby + 'px';
                                    }
                                }
                            }
                            (onDrop || (() => { }))(isGroupMove);
                        } else {
                            if (!e.ctrlKey && !e.shiftKey && appState.selectedPlayers.size > 1) {
                                InteractionManager.clearSelection();
                                playerEl.classList.add('selected');
                                appState.selectedPlayers.add(playerEl);
                            }
                        }
                    };

                    document.addEventListener('pointermove', onMove, { passive: false });
                    document.addEventListener('pointerup', onUp, { passive: false });
                };

                playerEl.addEventListener('pointerdown', onDown, { passive: false });
                playerEl.ondragstart = () => false;
            },
            
            placeBall(x = WIDTH * 0.5, y = HEIGHT * 0.5) {
                dom.ball.style.left = x + 'px';
                dom.ball.style.top = y + 'px';
                dom.ball.style.transform = 'translate(-50%, -50%) rotate(-15deg)';
            },
            
            enableDragBall(onDrop) {
                if (!isAuthorized) return;
                
                let pointerId = null, startX = 0, startY = 0, origL = 0, origT = 0;
                let passerEl = null;

                const onDown = e => {
                    if (appState.tool !== 'select') return;
                    
                    pointerId = e.pointerId;
                    dom.ball.setPointerCapture(pointerId);
                    e.preventDefault();
                    startX = e.clientX; startY = e.clientY;
                    origL = parseFloat(dom.ball.style.left) || 0;
                    origT = parseFloat(dom.ball.style.top) || 0;

                    InteractionManager.clearSelection();

                    const b0 = centerOf(dom.ball);
                    passerEl = (function () {
                        let best = null, bestD = Infinity;
                        for (const el of dom.playersLayer.children) {
                            const p = centerOf(el);
                            const d = dist(b0.x, b0.y, p.x, p.y);
                            if (d < 28 && d < bestD) { best = el; bestD = d; }
                        }
                        return best;
                    })();

                    if (passerEl) {
                        const p = centerOf(passerEl);
                        UnitsManager.setPassPreview(p.x, p.y, b0.x, b0.y);
                    }

                    const onMove = ev => {
                        if (ev.pointerId !== pointerId) return;
                        ev.preventDefault();
                        const { dx, dy } = LayoutManager.deltaToBoard(ev.clientX - startX, ev.clientY - startY);
                        let nx = clamp(origL + dx, 0, WIDTH);
                        let ny = clamp(origT + dy, 0, HEIGHT);
                        dom.ball.style.left = nx + 'px';
                        dom.ball.style.top = ny + 'px';

                        if (passerEl) {
                            const p = centerOf(passerEl);
                            UnitsManager.setPassPreview(p.x, p.y, nx, ny);
                        }
                    };

                    const onUp = ev => {
                        if (ev.pointerId !== pointerId) return;
                        try { dom.ball.releasePointerCapture(pointerId); } catch { }
                        document.removeEventListener('pointermove', onMove);
                        document.removeEventListener('pointerup', onUp);
                        UnitsManager.clearPassPreview();

                        if (dom.snapToggle.checked) {
                            dom.ball.style.left = snap(parseFloat(dom.ball.style.left)) + 'px';
                            dom.ball.style.top = snap(parseFloat(dom.ball.style.top)) + 'px';
                        }
                        (onDrop || (() => { }))();
                    };

                    document.addEventListener('pointermove', onMove, { passive: false });
                    document.addEventListener('pointerup', onUp, { passive: false });
                };

                dom.ball.addEventListener('pointerdown', onDown, { passive: false });
                dom.ball.ondragstart = () => false;
            },
            
            setPassPreview(x1, y1, x2, y2) {
                let passEl = document.getElementById('passPreview');
                if (!passEl) {
                    passEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    passEl.id = 'passPreview';
                    passEl.setAttribute('stroke', 'var(--yellow)');
                    passEl.setAttribute('stroke-width', '5');
                    passEl.setAttribute('stroke-dasharray', '12 8');
                    passEl.style.pointerEvents = 'none';
                    dom.draw.prepend(passEl);
                }
                passEl.setAttribute('x1', x1);
                passEl.setAttribute('y1', y1);
                passEl.setAttribute('x2', x2);
                passEl.setAttribute('y2', y2);
            },
            
            clearPassPreview() {
                const passEl = document.getElementById('passPreview');
                if (passEl) passEl.remove();
            }
        };

        // --- GESTI√ìN DE INTERACCIONES ---
        const InteractionManager = {
            enableSelectionBox() {
                if (!isAuthorized) return;
                
                let selectionPid = null;
                let selectionStart = null;
                let hasMoved = false;

                dom.board.addEventListener('pointerdown', (e) => {
                    if (appState.tool !== 'select') return;
                    
                    if (e.target.closest('.player') || e.target.closest('#ball')) return;

                    selectionPid = e.pointerId;
                    dom.board.setPointerCapture(selectionPid);
                    e.preventDefault();
                    selectionStart = LayoutManager.clientToBoard(e);
                    hasMoved = false;
                    
                    dom.selectionBox.style.left = selectionStart.x + 'px';
                    dom.selectionBox.style.top = selectionStart.y + 'px';
                    dom.selectionBox.style.width = '0';
                    dom.selectionBox.style.height = '0';
                    
                    if (!e.ctrlKey && !e.shiftKey) {
                        InteractionManager.clearSelection();
                    }

                    const onMove = (ev) => {
                        if (ev.pointerId !== selectionPid) return;
                        ev.preventDefault();
                        
                        // Determinar si hay movimiento real
                        if (Math.abs(ev.clientX - startX) > 5 || Math.abs(ev.clientY - startY) > 5) {
                            hasMoved = true;
                            dom.selectionBox.style.display = 'block';
                        }
                        
                        if (!hasMoved) return;

                        const current = LayoutManager.clientToBoard(ev);
                        const left = Math.min(selectionStart.x, current.x);
                        const top = Math.min(selectionStart.y, current.y);
                        const right = Math.max(selectionStart.x, current.x);
                        const bottom = Math.max(selectionStart.y, current.y);
                        
                        dom.selectionBox.style.left = left + 'px';
                        dom.selectionBox.style.top = top + 'px';
                        dom.selectionBox.style.width = (right - left) + 'px';
                        dom.selectionBox.style.height = (bottom - top) + 'px';

                        InteractionManager.selectPlayersInArea(left, top, right, bottom, e.ctrlKey || e.shiftKey);
                    };

                    const onUp = (ev) => {
                        if (ev.pointerId !== selectionPid) return;
                        try { dom.board.releasePointerCapture(selectionPid); } catch {}
                        document.removeEventListener('pointermove', onMove);
                        document.removeEventListener('pointerup', onUp);
                        dom.selectionBox.style.display = 'none';
                        selectionPid = null;
                        
                        if (!hasMoved) {
                            InteractionManager.clearSelection();
                        }
                    };

                    document.addEventListener('pointermove', onMove, { passive: false });
                    document.addEventListener('pointerup', onUp, { passive: false });
                });
            },

            selectPlayersInArea(left, top, right, bottom, additive = false) {
                if (!additive) {
                    appState.selectedPlayers.forEach(player => player.classList.remove('selected'));
                    appState.selectedPlayers.clear();
                }

                [...dom.playersLayer.children].forEach(player => {
                    const playerX = parseFloat(player.style.left);
                    const playerY = parseFloat(player.style.top);
                    const radius = 20;

                    const isOver = (playerX + radius >= left && playerX - radius <= right && 
                                    playerY + radius >= top && playerY - radius <= bottom);

                    if (isOver) {
                        if (!player.classList.contains('selected')) {
                             player.classList.add('selected');
                             appState.selectedPlayers.add(player);
                        }
                    } else if (!additive) {
                        if (player.classList.contains('selected')) {
                            player.classList.remove('selected');
                            appState.selectedPlayers.delete(player);
                        }
                    }
                });
            },

            clearSelection() {
                appState.selectedPlayers.forEach(player => player.classList.remove('selected'));
                appState.selectedPlayers.clear();
            },

            reinitializePlayerInteractions() {
                if (!isAuthorized) return;
                
                [...dom.playersLayer.children].forEach(player => {
                    const newPlayer = player.cloneNode(true);
                    player.parentNode.replaceChild(newPlayer, player);
                    
                    UnitsManager.enableDragPlayer(newPlayer, (isGroupMove) => {
                        StorageManager.savePositions();
                        if (dom.autoRecordChk.checked && !isGroupMove) TimelineManager.recordFrame();
                    });
                });
            }
        };

        // --- GESTI√ìN DE HERRAMIENTAS ---
        const ToolManager = {
            setTool(tool) {
                if (!isAuthorized) return;
                
                appState.tool = tool;
                
                dom.toolSelectBtn.classList.remove('active', 'alt');
                dom.toolArrowsBtn.classList.remove('active', 'alt');
                dom.toolPenBtn.classList.remove('active', 'alt');
                
                if (tool === 'select') {
                    dom.toolSelectBtn.classList.add('active');
                    dom.toolArrowsBtn.classList.add('alt');
                    dom.toolPenBtn.classList.add('alt');
                    dom.toolSelectBtn.textContent = 'Selezione: Attivo';
                    dom.toolArrowsBtn.textContent = 'Frecce';
                    dom.toolPenBtn.textContent = 'Matita';
                    
                    // Desactivar pointer events en la capa de dibujo para que la selecci√≥n funcione en el board
                    dom.draw.style.pointerEvents = 'none'; 
                    
                } else if (tool === 'arrows') {
                    dom.toolArrowsBtn.classList.add('active');
                    dom.toolSelectBtn.classList.add('alt');
                    dom.toolPenBtn.classList.add('alt');
                    dom.toolArrowsBtn.textContent = 'Frecce: Attivo';
                    dom.toolSelectBtn.textContent = 'Selezione';
                    dom.toolPenBtn.textContent = 'Matita';
                    
                    // Activar pointer events para dibujar flechas
                    dom.draw.style.pointerEvents = 'auto'; 
                    
                } else if (tool === 'pen') {
                    dom.toolPenBtn.classList.add('active');
                    dom.toolSelectBtn.classList.add('alt');
                    dom.toolArrowsBtn.classList.add('alt');
                    dom.toolPenBtn.textContent = 'Matita: Attiva';
                    dom.toolSelectBtn.textContent = 'Selezione';
                    dom.toolArrowsBtn.textContent = 'Frecce';
                    
                    // Activar pointer events para dibujar l√≠neas
                    dom.draw.style.pointerEvents = 'auto';
                }
                
                if (tool !== 'select') {
                    InteractionManager.clearSelection();
                }
                
                console.log(`üõ†Ô∏è Herramienta cambiada a: ${tool}`);
            }
        };

        // --- GESTI√ìN DE DIBUJO ---
        const DrawManager = {
            clearDraw() {
                if (!isAuthorized) return;
                dom.draw.innerHTML = '';
                appState.arrows = [];
                appState.strokes = [];
                StorageManager.saveArrows();
                StorageManager.saveStrokes();
            },
            clearArrows() {
                if (!isAuthorized) return;
                appState.arrows = [];
                DrawManager.renderDraw();
                StorageManager.saveArrows();
            },
            clearStrokes() {
                if (!isAuthorized) return;
                appState.strokes = [];
                DrawManager.renderDraw();
                StorageManager.saveStrokes();
            },
            undoLast() {
                if (!isAuthorized) return;
                
                const lastArrow = appState.arrows[appState.arrows.length - 1];
                const lastStroke = appState.strokes[appState.strokes.length - 1];
                
                const lastArrowTime = lastArrow ? lastArrow.timestamp || 0 : 0;
                const lastStrokeTime = lastStroke ? lastStroke.timestamp || 0 : 0;

                if (lastArrowTime > lastStrokeTime) {
                    appState.arrows.pop();
                    StorageManager.saveArrows();
                } else if (lastStrokeTime > 0) {
                    appState.strokes.pop();
                    StorageManager.saveStrokes();
                }
                DrawManager.renderDraw();
            },
            
            renderDraw() {
                dom.draw.innerHTML = '';
                
                let defs = dom.draw.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    dom.draw.appendChild(defs);
                }
                defs.innerHTML = ''; 

                // Renderizar Trazo (Matita)
                appState.strokes.forEach(stroke => {
                    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                    const points = stroke.points.map(p => `${p.x},${p.y}`).join(' ');
                    polyline.setAttribute('points', points);
                    polyline.setAttribute('fill', 'none');
                    polyline.setAttribute('stroke', stroke.color);
                    polyline.setAttribute('stroke-width', stroke.width);
                    polyline.setAttribute('stroke-linecap', 'round');
                    polyline.setAttribute('stroke-linejoin', 'round');
                    if (stroke.dashed) polyline.setAttribute('stroke-dasharray', '12 8');
                    dom.draw.appendChild(polyline);
                });

                // Renderizar Flechas (Frecce)
                appState.arrows.forEach((arrow, index) => {
                    const { x1, y1, x2, y2, color, width, dashed } = arrow;

                    const markerId = `arrowHead-${color.replace('#', '')}-${width}`;

                    if (!defs.querySelector(`#${markerId}`)) {
                        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                        marker.setAttribute('id', markerId);
                        marker.setAttribute('viewBox', '0 0 10 10');
                        marker.setAttribute('refX', '10'); 
                        marker.setAttribute('refY', '5');
                        marker.setAttribute('markerUnits', 'strokeWidth');
                        marker.setAttribute('markerWidth', parseFloat(width) * 0.7); 
                        marker.setAttribute('markerHeight', parseFloat(width) * 0.7);
                        marker.setAttribute('orient', 'auto-start-reverse'); 
                        
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                        path.setAttribute('fill', color);
                        marker.appendChild(path);
                        defs.appendChild(marker);
                    }

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                    line.setAttribute('stroke', color);
                    line.setAttribute('stroke-width', width);
                    line.setAttribute('stroke-linecap', 'round');
                    if (dashed) line.setAttribute('stroke-dasharray', '12 8');

                    line.setAttribute('marker-end', `url(#${markerId})`);
                    
                    dom.draw.appendChild(line);
                });
                UnitsManager.clearPassPreview();
            },
            
            enableDrawing() {
                // Se adjunta a dom.draw.
                dom.draw.removeEventListener('pointerdown', DrawManager.onPointerDown, { passive: false });
                dom.draw.addEventListener('pointerdown', DrawManager.onPointerDown, { passive: false });
            },
            
            // CORRECCI√ìN CR√çTICA FINAL: Usamos document para onMove/onUp cuando dibujamos, lo que es crucial para SVG.
            onPointerDown(e) {
                if (!isAuthorized) return;
                if (e.button !== 0) return;
                if (appState.tool === 'select') return;
                // Si el clic se hizo sobre un jugador o la pelota, ignorar.
                if (e.target.closest('.player') || e.target.closest('#ball')) return; 

                e.preventDefault();
                
                let pointerId = e.pointerId;
                let startPoint = LayoutManager.clientToBoard(e);
                
                // 1. Iniciar estado
                if (appState.tool === 'arrows') {
                    appState.drawingArrow = true;
                    DrawManager.drawArrowPreview(startPoint.x, startPoint.y, startPoint.x, startPoint.y);
                } else if (appState.tool === 'pen') {
                    appState.drawingStroke = true;
                    appState.currentStroke = {
                        points: [{ x: startPoint.x, y: startPoint.y }],
                        color: dom.strokeColorSel.value,
                        width: dom.strokeWidthSel.value,
                        dashed: dom.dashedToggle.checked,
                        timestamp: Date.now()
                    };
                }

                // 2. Capturar el puntero en el elemento que inici√≥ el evento
                if (e.target.setPointerCapture) {
                    e.target.setPointerCapture(pointerId);
                } else if (dom.draw.setPointerCapture) {
                    dom.draw.setPointerCapture(pointerId);
                }

                // 3. Handlers de movimiento y finalizaci√≥n
                const onMove = ev => {
                    if (ev.pointerId !== pointerId) return;
                    ev.preventDefault();
                    const { x, y } = LayoutManager.clientToBoard(ev);
                    const currX = clamp(x, 0, WIDTH);
                    const currY = clamp(y, 0, HEIGHT);

                    if (appState.tool === 'arrows' && appState.drawingArrow) {
                        DrawManager.drawArrowPreview(startPoint.x, startPoint.y, currX, currY);
                    } else if (appState.tool === 'pen' && appState.drawingStroke) {
                        const lastPoint = appState.currentStroke.points[appState.currentStroke.points.length - 1];
                        // Solo a√±adir si la distancia es suficiente
                        if (dist(lastPoint.x, lastPoint.y, currX, currY) > 5) { 
                            appState.currentStroke.points.push({ x: currX, y: currY });
                            DrawManager.drawStrokePreview(appState.currentStroke);
                        }
                    }
                };

                const onUp = ev => {
                    if (ev.pointerId !== pointerId) return;
                    
                    // Liberar captura
                    try { 
                        if (ev.target.releasePointerCapture) ev.target.releasePointerCapture(pointerId);
                        if (dom.draw.releasePointerCapture) dom.draw.releasePointerCapture(pointerId);
                    } catch {}
                    
                    // Eliminar listeners de DOCUMENT
                    document.removeEventListener('pointermove', onMove);
                    document.removeEventListener('pointerup', onUp);
                    
                    DrawManager.clearPreview();

                    const { x, y } = LayoutManager.clientToBoard(ev);
                    const endX = clamp(x, 0, WIDTH);
                    const endY = clamp(y, 0, HEIGHT);
                    
                    // 4. Finalizar dibujo y guardar
                    if (appState.tool === 'arrows' && appState.drawingArrow) {
                        if (dist(startPoint.x, startPoint.y, endX, endY) > 10) {
                            appState.arrows.push({
                                x1: startPoint.x, y1: startPoint.y,
                                x2: endX, y2: endY,
                                color: dom.strokeColorSel.value,
                                width: dom.strokeWidthSel.value,
                                dashed: dom.dashedToggle.checked,
                                timestamp: Date.now()
                            });
                            StorageManager.saveArrows();
                        }
                        appState.drawingArrow = false;
                    } else if (appState.tool === 'pen' && appState.drawingStroke) {
                        if (appState.currentStroke.points.length > 1) {
                            appState.strokes.push(appState.currentStroke);
                            StorageManager.saveStrokes();
                        }
                        appState.drawingStroke = false;
                        appState.currentStroke = null;
                    }
                    
                    DrawManager.renderDraw();
                    if (dom.autoRecordChk.checked) TimelineManager.recordFrame();
                };

                // 5. Adjuntar listeners a DOCUMENT (m√°s robusto para arrastre)
                document.addEventListener('pointermove', onMove, { passive: false });
                document.addEventListener('pointerup', onUp, { passive: false });
            },

            drawArrowPreview(x1, y1, x2, y2) {
                let line = document.getElementById('arrowPreviewLine');
                let head = document.getElementById('arrowPreviewHead');
                
                if (!line) {
                    line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    head = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    line.id = 'arrowPreviewLine';
                    head.id = 'arrowPreviewHead';
                    dom.draw.appendChild(line);
                    dom.draw.appendChild(head);
                }
                
                const color = dom.strokeColorSel.value;
                const width = parseFloat(dom.strokeWidthSel.value);
                const dashed = dom.dashedToggle.checked;

                line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                line.setAttribute('stroke', color); line.setAttribute('stroke-width', width);
                line.setAttribute('stroke-linecap', 'round');
                if (dashed) line.setAttribute('stroke-dasharray', '12 8'); else line.removeAttribute('stroke-dasharray');
                line.removeAttribute('marker-end'); 

                const angle = Math.atan2(y2 - y1, x2 - x1);
                const size = width * 2.5; 
                const points = [
                    `${x2},${y2}`,
                    `${x2 - size * Math.cos(angle - Math.PI / 6)},${y2 - size * Math.sin(angle - Math.PI / 6)}`,
                    `${x2 - size * Math.cos(angle + Math.PI / 6)},${y2 - size * Math.sin(angle + Math.PI / 6)}`
                ];
                head.setAttribute('points', points.join(' '));
                head.setAttribute('fill', color);
            },
            
            drawStrokePreview(stroke) {
                let polyline = document.getElementById('strokePreview');
                if (!polyline) {
                    polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                    polyline.id = 'strokePreview';
                    dom.draw.appendChild(polyline);
                }
                const points = stroke.points.map(p => `${p.x},${p.y}`).join(' ');
                polyline.setAttribute('points', points);
                polyline.setAttribute('fill', 'none');
                polyline.setAttribute('stroke', stroke.color);
                polyline.setAttribute('stroke-width', stroke.width);
                polyline.setAttribute('stroke-linecap', 'round');
                polyline.setAttribute('stroke-linejoin', 'round');
                if (stroke.dashed) polyline.setAttribute('stroke-dasharray', '12 8'); else polyline.removeAttribute('stroke-dasharray');
            },
            
            clearPreview() {
                const arr = document.getElementById('arrowPreviewLine'); if (arr) arr.remove();
                const head = document.getElementById('arrowPreviewHead'); if (head) head.remove();
                const strk = document.getElementById('strokePreview'); if (strk) strk.remove();
            },
            
            onPointerUp(e) {
                // Se deja vac√≠o.
            }
        };

        // --- GESTI√ìN DE ANIMACI√ìN ---
        const TimelineManager = {
            recordFrame() {
                if (!isAuthorized) return;
                const players = [...dom.playersLayer.children].map(el => ({
                    team: el.dataset.team, number: +el.dataset.number,
                    x: parseFloat(el.style.left), y: parseFloat(el.style.top)
                }));
                const ball = { x: parseFloat(dom.ball.style.left) || WIDTH / 2, y: parseFloat(dom.ball.style.top) || HEIGHT / 2 };
                const arrows = JSON.parse(JSON.stringify(appState.arrows));
                const strokes = JSON.parse(JSON.stringify(appState.strokes));

                const newFrame = { players, ball, arrows, strokes };

                if (appState.playing) {
                    appState.timeline.push(newFrame);
                    appState.playIndex = appState.timeline.length - 1;
                } else if (appState.playIndex < appState.timeline.length) {
                    appState.timeline.splice(appState.playIndex + 1, appState.timeline.length, newFrame);
                    appState.playIndex++;
                } else {
                    appState.timeline.push(newFrame);
                    appState.playIndex = appState.timeline.length - 1;
                }

                TimelineManager.updateScrubber();
                StorageManager.saveTimeline();
            },
            clearTimeline() {
                if (!isAuthorized) return;
                if (!confirm('¬øEst√°s seguro de que quieres eliminar la animaci√≥n? Esto no afecta las posiciones de inicio.')) return;
                appState.timeline = [];
                appState.playIndex = 0;
                TimelineManager.updateScrubber();
                StorageManager.saveTimeline();
            },
            renderInterpolatedFrame(fromIndex, t) {
                if (isNaN(t)) t = 0;
                if (t < 0) t = 0;
                if (t > 1) t = 1;

                const f0 = appState.timeline[fromIndex];
                const f1 = appState.timeline[fromIndex + 1];
                if (!f0 || !f1) {
                    if (f0) TimelineManager.loadFrame(fromIndex);
                    return;
                }

                const playersMap = new Map();
                [...dom.playersLayer.children].forEach(el => playersMap.set(el.dataset.team + el.dataset.number, el));
                f0.players.forEach(p0 => {
                    const el = playersMap.get(p0.team + p0.number);
                    if (el) {
                        const p1 = f1.players.find(pp => pp.team === p0.team && pp.number === p0.number) || p0;
                        const ix = lerp(p0.x, p1.x, t);
                        const iy = lerp(p0.y, p1.y, t);
                        el.style.left = ix + 'px';
                        el.style.top = iy + 'px';
                    }
                });

                const bx = lerp(f0.ball.x, f1.ball.x, t);
                const by = lerp(f0.ball.y, f1.ball.y, t);
                UnitsManager.placeBall(bx, by);

                appState.arrows = JSON.parse(JSON.stringify(f0.arrows));
                appState.strokes = JSON.parse(JSON.stringify(f0.strokes));
                DrawManager.renderDraw();

                appState.playIndex = fromIndex;
                TimelineManager.updateScrubber();
                LayoutManager.applyUprightTransforms();
            },
            loadFrame(index) {
                index = clamp(index, 0, appState.timeline.length > 0 ? appState.timeline.length - 1 : 0);
                
                const frame = appState.timeline[index];
                if (!frame) return;

                const playersMap = new Map();
                [...dom.playersLayer.children].forEach(el => playersMap.set(el.dataset.team + el.dataset.number, el));
                frame.players.forEach(p => {
                    const el = playersMap.get(p.team + p.number);
                    if (el) {
                        el.style.left = p.x + 'px';
                        el.style.top = p.y + 'px';
                    }
                });

                UnitsManager.placeBall(frame.ball.x, frame.ball.y);

                appState.arrows = JSON.parse(JSON.stringify(frame.arrows));
                appState.strokes = JSON.parse(JSON.stringify(frame.strokes));
                DrawManager.renderDraw();

                appState.playIndex = index;
                TimelineManager.updateScrubber();
                LayoutManager.applyUprightTransforms();
                
                if (!appState.playing) {
                    StorageManager.savePositions();
                    StorageManager.saveBall();
                    StorageManager.saveArrows();
                    StorageManager.saveStrokes();
                }
            },
            updateScrubber() {
                const count = appState.timeline.length;
                dom.frameCountEl.textContent = count;
                dom.frameTotal.textContent = count;
                dom.scrubber.max = Math.max(0, count - 1);
                dom.scrubber.value = appState.playIndex;
                dom.scrubberVal.textContent = appState.playIndex;
                if (count === 0) dom.scrubber.value = 0;
            },
            handleScrubberChange(e) {
                const index = parseInt(e.target.value);
                if (index < appState.timeline.length) {
                    TimelineManager.loadFrame(index);
                }
            },
            play(timestamp) {
                if (!appState.playing || appState.timeline.length < 2) {
                    appState.playing = false;
                    appState.paused = false;
                    dom.playBtn.textContent = 'Play';
                    return;
                }

                if (appState.paused) return;

                const dur = (isNaN(appState.segmentDuration) || appState.segmentDuration < 16) ? 800 : appState.segmentDuration;

                if (appState.fromFrame == null) {
                    if (isNaN(appState.playIndex) || appState.playIndex < 0 || appState.playIndex >= appState.timeline.length - 1) {
                        appState.playIndex = 0;
                    }
                    appState.fromFrame = appState.playIndex;
                    appState.segmentStartTime = timestamp;
                    TimelineManager.loadFrame(appState.fromFrame); 
                }

                if (appState.fromFrame >= appState.timeline.length - 1) {
                    appState.playing = false;
                    appState.paused = false;
                    appState.fromFrame = null;
                    dom.playBtn.textContent = 'Play';
                    TimelineManager.updateScrubber();
                    return;
                }

                const elapsed = timestamp - appState.segmentStartTime;
                let t = elapsed / dur;

                if (t >= 1) {
                    appState.fromFrame += 1;
                    appState.playIndex = appState.fromFrame;
                    appState.segmentStartTime = timestamp;

                    if (appState.fromFrame >= appState.timeline.length - 1) {
                        TimelineManager.loadFrame(appState.fromFrame); 
                        appState.playing = false;
                        appState.paused = false;
                        appState.fromFrame = null;
                        dom.playBtn.textContent = 'Play';
                        TimelineManager.updateScrubber();
                        return;
                    } else {
                        TimelineManager.renderInterpolatedFrame(appState.fromFrame, 0); 
                    }
                } else {
                    TimelineManager.renderInterpolatedFrame(appState.fromFrame, t);
                }

                appState.rafId = requestAnimationFrame(TimelineManager.play);
            },
            startPlay() {
                if (appState.timeline.length < 2) return;
                const val = parseInt(dom.speedInput.value);
                appState.segmentDuration = (isNaN(val) || val < 16) ? 800 : val;
                appState.playing = true;
                appState.paused = false;
                if (appState.fromFrame === null) appState.playIndex = 0; 
                appState.fromFrame = null;
                dom.playBtn.textContent = 'Playing...';
                dom.pauseBtn.textContent = 'Pause'; 
                cancelAnimationFrame(appState.rafId);
                appState.rafId = requestAnimationFrame(TimelineManager.play);
            },
            pausePlay() {
                if (!appState.playing) return;
                appState.paused = true;
                try { cancelAnimationFrame(appState.rafId); } catch (e) {}
                dom.playBtn.textContent = 'Riprendi'; 
                dom.pauseBtn.textContent = 'Pausa: Attiva';
            },
            stopPlay() {
                appState.playing = false;
                appState.paused = false;
                appState.fromFrame = null;
                try { cancelAnimationFrame(appState.rafId); } catch (e) {}
                appState.fromFrame = null;
                dom.playBtn.textContent = 'Play';
                dom.pauseBtn.textContent = 'Pause';
                cancelAnimationFrame(appState.rafId);
                TimelineManager.loadFrame(0);
            }
        };

        // --- GESTI√ìN DE ALMACENAMIENTO ---
        const StorageManager = {
            async savePlay() {
                if (!isAuthorized || !currentUser) {
                    alert('üî¥ Usuario no autenticado');
                    return;
                }
                
                const name = dom.playNameInput.value?.trim();
                if (!name) { 
                    alert('‚ùå Inserisci un nome per la giocata.'); 
                    return; 
                }
                
                if (appState.timeline.length === 0) { 
                    alert('‚ùå Aggiungi almeno un frame all\'animazione per salvare la giocata.'); 
                    return; 
                }
                
                const playData = {
                    name,
                    timeline: appState.timeline,
                    arrows: appState.arrows,
                    strokes: appState.strokes,
                    positions: [...dom.playersLayer.children].map(el => ({ 
                        team: el.dataset.team, 
                        number: +el.dataset.number, 
                        x: parseFloat(el.style.left), 
                        y: parseFloat(el.style.top) 
                    })),
                    ball: centerOf(dom.ball),
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    createdBy: currentUser.uid,
                    email: currentUser.email
                };

                if (firebaseConnected && db) {
                    try {
                        const playRef = doc(db, "users", currentUser.uid, "plays", name);
                        await setDoc(playRef, playData);
                        
                        PopupManager.showSuccess(`‚úÖ Giocata "${name}" salvata in Firebase!`);
                        
                        StorageManager.updatePlaySelect();
                        return;
                        
                    } catch (error) {
                        if (error.code === 'permission-denied') {
                            firebaseConnected = false;
                            AuthManager.updateFirebaseStatus(false, error);
                        }
                    }
                }

                try {
                    localStorage.setItem(PLAY_PREFIX + name, JSON.stringify(playData));
                    PopupManager.showSuccess(`üíæ Giocata "${name}" salvata localmente`);
                } catch (localError) {
                    alert('‚ùå Error grave: No se pudo guardar la jugada.');
                    return;
                }

                StorageManager.updatePlaySelect();
            },

            async loadPlay(name) {
                try {
                    let playData;
                    
                    if (db && currentUser) {
                        try {
                            const docRef = doc(db, "users", currentUser.uid, "plays", name);
                            const docSnap = await getDoc(docRef);
                            
                            if (docSnap.exists()) {
                                playData = docSnap.data();
                                localStorage.setItem(PLAY_PREFIX + name, JSON.stringify(playData));
                            } else {
                                throw new Error('Documento no existe en Firebase');
                            }
                        } catch (firebaseError) {
                            if (firebaseError.code === 'permission-denied' || 
                                firebaseError.code === 'permissions-denied') {
                                firebaseConnected = false;
                                AuthManager.updateFirebaseStatus(false, firebaseError);
                            }
                            
                            const rawData = localStorage.getItem(PLAY_PREFIX + name);
                            if (!rawData) {
                                alert("Giocata non trovata: " + name);
                                return;
                            }
                            playData = JSON.parse(rawData);
                        }
                    } else {
                        const rawData = localStorage.getItem(PLAY_PREFIX + name);
                        if (!rawData) {
                            alert("Giocata non trovata: " + name);
                            return;
                        }
                        playData = JSON.parse(rawData);
                    }

                    await this.processPlayData(playData, name);
                    
                } catch (error) {
                    alert('Errore nel caricamento della giocata: ' + error.message);
                }
            },

            async processPlayData(playData, name) {
                appState.timeline = playData.timeline || [];
                TimelineManager.updateScrubber();
                
                appState.arrows = playData.arrows || [];
                appState.strokes = playData.strokes || [];
                
                if (appState.timeline.length > 0) {
                    TimelineManager.loadFrame(0);
                } else if (playData.positions) {
                    const playersMap = new Map();
                    UnitsManager.createPlayers(); 
                    [...dom.playersLayer.children].forEach(el => playersMap.set(el.dataset.team + el.dataset.number, el));
                    
                    playData.positions.forEach(p => {
                        const el = playersMap.get(p.team + p.number);
                        if (el) {
                            el.style.left = p.x + 'px';
                            el.style.top = p.y + 'px';
                        }
                    });
                    UnitsManager.placeBall(playData.ball.x, playData.ball.y);
                    DrawManager.renderDraw();
                } else {
                    DrawManager.renderDraw();
                }

                dom.playNameInput.value = name;
                StorageManager.saveTimeline();
                StorageManager.saveArrows();
                StorageManager.saveStrokes();
                StorageManager.savePositions();
                StorageManager.saveBall();
                LayoutManager.applyUprightTransforms();
                
                PopupManager.showSuccess(`‚úÖ Giocata "${name}" caricata correttamente!`);
            },

            async deletePlay() {
                if (!isAuthorized || !currentUser) return;
                const name = dom.loadPlaySel.value;
                if (name && confirm(`¬øEst√°s seguro de que quieres eliminar la giocata "${name}"?`)) {
                    try {
                        if (db && firebaseConnected) {
                            await deleteDoc(doc(db, "users", currentUser.uid, "plays", name));
                        }
                        
                        localStorage.removeItem(PLAY_PREFIX + name);
                        StorageManager.updatePlaySelect();
                        dom.playNameInput.value = '';
                        
                        PopupManager.showSuccess(`‚úÖ Giocata "${name}" eliminata correttamente!`);
                        
                    } catch (error) {
                        localStorage.removeItem(PLAY_PREFIX + name);
                        StorageManager.updatePlaySelect();
                        dom.playNameInput.value = '';
                        
                        PopupManager.showSuccess(`‚ö†Ô∏è Giocata "${name}" eliminata localmente`);
                    }
                }
            },

            async updatePlaySelect() {
                dom.loadPlaySel.innerHTML = '<option value="">-- Carica giocata salvata --</option>';
                
                try {
                    let plays = [];
                    
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key.startsWith(PLAY_PREFIX)) {
                            const playName = key.substring(PLAY_PREFIX.length);
                            if (!plays.includes(playName)) {
                                plays.push(playName);
                            }
                        }
                    }
                    
                    if (db && currentUser && isAuthorized) {
                        try {
                            const q = query(
                                collection(db, "users", currentUser.uid, "plays"),
                                orderBy("updatedAt", "desc")
                            );
                            const querySnapshot = await getDocs(q);
                            
                            querySnapshot.forEach((doc) => {
                                const playName = doc.id;
                                if (!plays.includes(playName)) {
                                    plays.push(playName);
                                }
                            });
                            
                        } catch (firebaseError) {
                        }
                    }
                    
                    plays.sort().forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        dom.loadPlaySel.appendChild(option);
                    });
                    
                } catch (error) {
                    StorageManager.loadFromLocalStorageOnly();
                }
            },

            loadFromLocalStorageOnly() {
                dom.loadPlaySel.innerHTML = '<option value="">-- Carica giocata salvata --</option>';
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(PLAY_PREFIX)) {
                        const option = document.createElement('option');
                        option.value = key.substring(PLAY_PREFIX.length);
                        option.textContent = key.substring(PLAY_PREFIX.length);
                        dom.loadPlaySel.appendChild(option);
                    }
                }
            },

            savePositions() {
                const positions = [...dom.playersLayer.children].map(el => ({
                    team: el.dataset.team, number: +el.dataset.number,
                    x: parseFloat(el.style.left), y: parseFloat(el.style.top)
                }));
                localStorage.setItem(POS_KEY, JSON.stringify(positions));
            },

            loadPositions() {
                const saved = localStorage.getItem(POS_KEY);
                if (!saved) { UnitsManager.createPlayers(); return; }
                const positions = JSON.parse(saved);
                const playersMap = new Map();
                UnitsManager.createPlayers();
                [...dom.playersLayer.children].forEach(el => playersMap.set(el.dataset.team + el.dataset.number, el));
                positions.forEach(p => {
                    const el = playersMap.get(p.team + p.number);
                    if (el) {
                        el.style.left = p.x + 'px';
                        el.style.top = p.y + 'px';
                    }
                });
                UnitsManager.countPlayers();
                LayoutManager.applyUprightTransforms();
            },

            saveBall() {
                const ball = centerOf(dom.ball);
                localStorage.setItem(BALL_KEY, JSON.stringify(ball));
            },

            loadBall() {
                const saved = localStorage.getItem(BALL_KEY);
                if (!saved) return;
                const pos = JSON.parse(saved);
                UnitsManager.placeBall(pos.x, pos.y);
            },

            saveArrows() { localStorage.setItem(ARROW_KEY, JSON.stringify(appState.arrows)); },
            
            loadArrows() {
                const saved = localStorage.getItem(ARROW_KEY);
                if (saved) appState.arrows = JSON.parse(saved);
            },

            saveStrokes() { localStorage.setItem(STROKE_KEY, JSON.stringify(appState.strokes)); },
            
            loadStrokes() {
                const saved = localStorage.getItem(STROKE_KEY);
                if (saved) appState.strokes = JSON.parse(saved);
            },

            saveTimeline() {
                localStorage.setItem(TL_KEY, JSON.stringify(appState.timeline));
            },

            loadTimeline() {
                const saved = localStorage.getItem(TL_KEY);
                if (saved) appState.timeline = JSON.parse(saved);
                TimelineManager.updateScrubber();
            },

            exportTimeline() {
                const json = JSON.stringify(appState.timeline, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = (dom.playNameInput.value?.trim() || 'lavagna') + '_animazione.json';
                document.body.appendChild(a); a.click(); a.remove();
                URL.revokeObjectURL(url);
            },

            importTimeline() {
                const input = document.createElement('input');
                input.type = 'file'; input.accept = 'application/json';
                input.onchange = e => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = e => {
                        try {
                            const json = e.target.result;
                            const timeline = JSON.parse(json);
                            if (Array.isArray(timeline) && timeline.every(f => f.players && f.ball)) {
                                appState.timeline = timeline;
                                StorageManager.saveTimeline();
                                TimelineManager.loadFrame(0);
                                alert(`Animazione importata: ${timeline.length} frames.`);
                            } else {
                                throw new Error("Formato JSON non valido per la timeline.");
                            }
                        } catch (err) {
                            alert(`Errore nell'importazione: ${err.message}`);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            },

            duplicatePlay() {
                if (!isAuthorized) return;
                const originalName = dom.playNameInput.value?.trim();
                if (!originalName) { alert('Carica prima una giocata per duplicarla.'); return; }
                const newName = prompt(`Duplicar "${originalName}" como:`);
                if (newName && newName.trim()) {
                    const rawData = localStorage.getItem(PLAY_PREFIX + originalName);
                    if (rawData) {
                        localStorage.setItem(PLAY_PREFIX + newName.trim(), rawData);
                        dom.playNameInput.value = newName.trim();
                        StorageManager.savePlay(); 
                        StorageManager.updatePlaySelect();
                        dom.loadPlaySel.value = newName.trim();
                        PopupManager.showSuccess(`‚úÖ Giocata duplicata come "${newName.trim()}".`);
                    } else {
                        alert(`‚ùå Giocata "${originalName}" non trovata in local storage.`);
                    }
                }
            },
        };

        // --- EXPORTACI√ìN ---
        const ExportManager = {
            async drawPitch(ctx) {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                ctx.fillStyle = '#137a46'; 
                ctx.fillRect(0, 0, WIDTH, HEIGHT); 

                const svgEl = dom.board.querySelector('.lines').cloneNode(true);
                const drawEl = dom.draw.cloneNode(true); 

                let tempLabels = [];
                if (dom.toggleLabelsBtn.classList.contains('active')) {
                    [...dom.playersLayer.children].forEach(el => {
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.classList.add('label');
                        label.setAttribute('x', parseFloat(el.style.left)); 
                        label.setAttribute('y', parseFloat(el.style.top) + 20 + 5); 
                        label.setAttribute('text-anchor', 'middle');
                        label.setAttribute('alignment-baseline', 'central');

                        label.textContent = el.textContent; 
                        svgEl.appendChild(label);
                        tempLabels.push(label);
                    });
                }

                while (drawEl.firstChild) {
                    svgEl.appendChild(drawEl.firstChild);
                }
                
                const defs = dom.draw.querySelector('defs');
                if (defs) {
                    svgEl.prepend(defs.cloneNode(true));
                }

                const svgData = new XMLSerializer().serializeToString(svgEl);
                const img = new Image();
                
                return new Promise(resolve => {
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0);
                        resolve();
                    };
                    img.onerror = (e) => {
                        console.error("Error cargando SVG del campo en canvas:", e);
                        resolve();
                    };
                    img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgData);
                });
            },

            drawPlayer(ctx, p) {
                const size = 40;
                const radius = size / 2;
                const font = 'bold 14px system-ui';
                
                ctx.save();
                ctx.translate(p.x, p.y);
                
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
                ctx.fillStyle = (p.team === 'blue' ? '#0d6efd' : '#e63946');
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = font;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.number, 0, 1);
                
                ctx.restore();
            },

            drawBall(ctx, b) {
                const W = 50, H = 30;
                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(-15 * Math.PI / 180);

                ctx.beginPath();
                ctx.ellipse(0, 0, W / 2, H / 2, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#ffd400';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.setLineDash([8, 6]);
                ctx.ellipse(0, 0, W / 2 - 6, H / 2 - 6, 0, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0,0,0,.25)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            },

            drawStroke(ctx, s) {
                if (s.points.length < 2) return;
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(s.points[0].x, s.points[0].y);
                for (let i = 1; i < s.points.length; i++) {
                    ctx.lineTo(s.points[i].x, s.points[i].y);
                }
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                if (s.dashed) ctx.setLineDash([12, 8]);
                ctx.stroke();
                ctx.restore();
            },

            drawArrow(ctx, a) {
                const { x1, y1, x2, y2, color, width, dashed } = a;
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const size = parseFloat(width) * 2.5;

                ctx.save();
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = width;
                ctx.lineCap = 'round';
                if (dashed) ctx.setLineDash([12, 8]);

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - size * Math.cos(angle - Math.PI / 6), y2 - size * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(x2 - size * Math.cos(angle + Math.PI / 6), y2 - size * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            },

            getCurrentPlayersFromDOM() { 
                return [...dom.playersLayer.children].map(el => ({ 
                    team: el.dataset.team, 
                    number: +el.dataset.number, 
                    x: parseFloat(el.style.left), 
                    y: parseFloat(el.style.top) 
                })); 
            },
            
            getCurrentBallFromDOM() { 
                return { 
                    x: parseFloat(dom.ball.style.left) || WIDTH / 2, 
                    y: parseFloat(dom.ball.style.top) || HEIGHT / 2 
                }; 
            },

            async renderFrameToCanvas(frameData, includeOverlays = true) {
                dom.ctx.clearRect(0, 0, WIDTH, HEIGHT);
                
                await ExportManager.drawPitch(dom.ctx); 
                
                frameData.players.forEach(p => ExportManager.drawPlayer(dom.ctx, p)); 
                ExportManager.drawBall(dom.ctx, frameData.ball);
            },

            setupExportUI() {
                if (!window.FFmpeg) {
                    dom.exportMp4Btn.disabled = true;
                    dom.exportMp4Btn.textContent = 'Exportar MP4 (instalar ffmpeg.wasm)';
                }

                dom.exportJpgBtn.addEventListener('click', async () => {
                    const playersNow = ExportManager.getCurrentPlayersFromDOM();
                    const ballNow = ExportManager.getCurrentBallFromDOM();
                    
                    await ExportManager.renderFrameToCanvas({ players: playersNow, ball: ballNow }, true);
                    
                    const url = dom.exportCanvas.toDataURL('image/jpeg', 0.95);
                    const a = document.createElement('a'); a.href = url; 
                    a.download = (dom.playNameInput.value?.trim() || 'lavagna') + '_frame.jpg'; 
                    document.body.appendChild(a); a.click(); a.remove();
                });

                dom.exportVideoBtn.addEventListener('click', async () => {
                    if (appState.timeline.length < 2) { alert('A√±ade al menos 2 frames a la animaci√≥n para exportar video.'); return; }
                    if (!dom.exportCanvas.captureStream) { alert('Tu navegador no soporta Canvas.captureStream para exportar WebM.'); return; }

                    dom.exportVideoBtn.textContent = 'Grabando... (Pulsa Stop para cancelar)';
                    dom.exportVideoBtn.disabled = true;
                    
                    TimelineManager.loadFrame(0);

                    const duration = parseInt(dom.speedInput.value);
                    const totalFrames = appState.timeline.length;
                    let currentFrameIndex = 0;
                    let isRecording = true;

                    const finalizeExport = (chunks) => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a'); a.href = url;
                        a.download = (dom.playNameInput.value?.trim() || 'lavagna') + '_animazione.webm';
                        document.body.appendChild(a); a.click(); a.remove();
                        URL.revokeObjectURL(url);
                        dom.exportVideoBtn.textContent = 'Exportar video (WebM)';
                        dom.exportVideoBtn.disabled = false;
                        TimelineManager.loadFrame(0); 
                    };
                    
                    const stream = dom.exportCanvas.captureStream(30);
                    const recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
                    const chunks = [];
                    recorder.ondataavailable = e => chunks.push(e.data);
                    recorder.onstop = () => finalizeExport(chunks);
                    recorder.start();
                    
                    const runFrame = async () => {
                        if (currentFrameIndex >= totalFrames || !isRecording) {
                            recorder.stop();
                            return;
                        }

                        TimelineManager.loadFrame(currentFrameIndex); 

                        await ExportManager.renderFrameToCanvas({
                            players: ExportManager.getCurrentPlayersFromDOM(),
                            ball: ExportManager.getCurrentBallFromDOM()
                        }, true); 
                        
                        currentFrameIndex++;
                        setTimeout(runFrame, duration);
                    };
                    
                    runFrame();
                });

                dom.exportMp4Btn.addEventListener('click', () => {
                    const win = window.open('exporter_mp4.html', '_blank', 'noopener');
                    if (!win) { alert('No pude abrir el exportador (popup bloqueado). Permit√≠ popups para este sitio.'); return; }
                    const payload = {
                        timeline: appState.timeline,
                        width: WIDTH,
                        height: HEIGHT,
                        segmentDuration: (isNaN(appState.segmentDuration) ? 800 : appState.segmentDuration),
                        name: (dom.playNameInput?.value?.trim() || 'lavagna')
                    };
                    function onReady(e){
                        if (e.source === win && e.data === 'EXPORTER_READY'){
                            window.removeEventListener('message', onReady);
                            win.postMessage(payload, '*');
                        }
                    }
                    window.addEventListener('message', onReady);
                });
            },
        };

        // --- UI/EVENT HANDLERS ---
        const UIManager = {
            setupEventListeners() {
                // Auth
                dom.btnLogin.addEventListener('click', () => AuthManager.login());
                dom.loginPassword.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') AuthManager.login();
                });
                dom.btnAuthAction.addEventListener('click', () => AuthManager.logout());

                // Layout
                window.addEventListener('resize', () => {
                    LayoutManager.fitBoard();
                    if (window.innerWidth <= 900 && dom.mainApp.style.display !== 'none') {
                        dom.menuBtn.style.display = 'grid';
                    } else {
                        dom.menuBtn.style.display = 'none';
                    }
                });
                dom.verticalFieldChk.addEventListener('change', () => { 
                    appState.layout.forceVertical = dom.verticalFieldChk.checked;
                    LayoutManager.fitBoard();
                });

                // Menu/Sidebar
                dom.menuBtn.addEventListener('click', () => { 
                    dom.sidebar.classList.add('open'); 
                    dom.scrim.classList.add('show'); 
                });
                dom.closeMenuBtn.addEventListener('click', () => { 
                    dom.sidebar.classList.remove('open'); 
                    dom.scrim.classList.remove('show'); 
                });
                dom.scrim.addEventListener('click', () => { 
                    dom.sidebar.classList.remove('open'); 
                    dom.scrim.classList.remove('show'); 
                });

                // Nuevo: Bot√≥n para agregar jugador
                dom.addPlayerBtn.addEventListener('click', () => {
                    if (!isAuthorized) return;
                    UnitsManager.addPlayer();
                });

                // Controles
                dom.resetBtn.addEventListener('click', () => { 
                    if (!isAuthorized) return;
                    UnitsManager.createPlayers(); 
                    UnitsManager.placeBall(); 
                    DrawManager.clearDraw(); 
                    StorageManager.savePositions(); 
                    StorageManager.saveBall(); 
                    StorageManager.saveArrows(); 
                    StorageManager.saveStrokes(); 
                });
                dom.snapToggle.addEventListener('change', () => { LayoutManager.renderGrid(); });
                dom.toggleLabelsBtn.addEventListener('click', (e) => {
                    e.target.classList.toggle('active');
                    e.target.textContent = e.target.classList.contains('active') ? 'Ocultar etichette' : 'Mostra etichette';
                    [...dom.playersLayer.children].forEach(el => el.style.fontSize = e.target.classList.contains('active') ? 'var(--player-font)' : '0');
                });

                // Herramientas
                dom.toolSelectBtn.addEventListener('click', () => ToolManager.setTool('select'));
                dom.toolArrowsBtn.addEventListener('click', () => ToolManager.setTool('arrows'));
                dom.toolPenBtn.addEventListener('click', () => ToolManager.setTool('pen'));
                
                // Dibujo
                dom.undoGenericBtn.addEventListener('click', DrawManager.undoLast);
                dom.clearArrowsBtn.addEventListener('click', DrawManager.clearArrows);
                dom.clearAllBtn.addEventListener('click', () => { 
                    if (!isAuthorized) return;
                    if (confirm('¬øQuieres eliminar todos los dibujos (frecce y l√≠neas)?')) DrawManager.clearDraw(); 
                });

                // Giocate/Plays
                dom.savePlayBtn.addEventListener('click', StorageManager.savePlay);
                dom.btnLoadPlay.addEventListener('click', () => { 
                    if (dom.loadPlaySel.value) StorageManager.loadPlay(dom.loadPlaySel.value); 
                });
                dom.deletePlayBtn.addEventListener('click', StorageManager.deletePlay);
                dom.duplicatePlayBtn.addEventListener('click', StorageManager.duplicatePlay);

                // Animaci√≥n
                dom.recordStepBtn.addEventListener('click', TimelineManager.recordFrame);
                dom.scrubber.addEventListener('input', TimelineManager.handleScrubberChange);
                dom.scrubber.addEventListener('change', TimelineManager.handleScrubberChange);
                dom.prevFrameBtn.addEventListener('click', () => TimelineManager.loadFrame(Math.max(0, appState.playIndex - 1)));
                dom.nextFrameBtn.addEventListener('click', () => TimelineManager.loadFrame(Math.min(appState.timeline.length - 1, appState.playIndex + 1)));
                dom.playBtn.addEventListener('click', TimelineManager.startPlay);
                dom.pauseBtn.addEventListener('click', TimelineManager.pausePlay);
                dom.stopBtn.addEventListener('click', TimelineManager.stopPlay);
                dom.clearTimelineBtn.addEventListener('click', TimelineManager.clearTimeline);
                dom.exportTimelineBtn.addEventListener('click', StorageManager.exportTimeline);
                dom.importTimelineBtn.addEventListener('click', StorageManager.importTimeline);

                // Exportaci√≥n
                ExportManager.setupExportUI();
            }
        };

        // ===== INIT =====
        async function init(){
            try {
                await AuthManager.init();
                
                if (isAuthorized && currentUser) {
                    console.log('üéØ Inicializando pizarra...');
                    
                    LayoutManager.renderGrid(); 
                    ToolManager.setTool('select');
                    UnitsManager.createPlayers(); 
                    StorageManager.loadPositions();
                    StorageManager.loadArrows(); 
                    StorageManager.loadStrokes(); 
                    DrawManager.renderDraw();
                    UnitsManager.placeBall(WIDTH/2, HEIGHT/2); 
                    StorageManager.loadBall();
                    StorageManager.loadTimeline(); 
                    TimelineManager.updateScrubber();
                    
                    if (!Array.isArray(appState.timeline) || appState.timeline.length === 0) {
                        TimelineManager.recordFrame();
                        appState.playIndex = 0;
                        TimelineManager.updateScrubber();
                        StorageManager.saveTimeline();
                    }

                    // Habilitar el dibujo
                    DrawManager.enableDrawing();
                    
                    UnitsManager.enableDragBall(() => { 
                        StorageManager.saveBall(); 
                        if (dom.autoRecordChk.checked) TimelineManager.recordFrame(); 
                    });
                    StorageManager.updatePlaySelect();
                    LayoutManager.fitBoard();
                    
                    InteractionManager.enableSelectionBox();
                    
                    console.log('‚úÖ Pizarra inicializada correctamente');
                }
                
                UIManager.setupEventListeners();
                console.log('‚úÖ Event listeners configurados');
                
            } catch (error) {
                console.error('‚ùå Error cr√≠tico en inicializaci√≥n:', error);
                alert('Error cr√≠tico al inicializar la aplicaci√≥n. Recarga la p√°gina.');
            }
        }

        // Funciones de debug (sin cambios)
        window.testFirebaseDebug = async function() {
            console.log('=== DEBUG FIREBASE ===');
            console.log('App:', app);
            console.log('DB:', db);
            console.log('Auth:', auth);
            console.log('Usuario:', currentUser);
            console.log('Conectado:', firebaseConnected);
            
            try {
                if (db && currentUser) {
                    const testDoc = doc(db, "users", currentUser.uid, "plays", "test-debug");
                    await setDoc(testDoc, { 
                        test: "debug", 
                        timestamp: new Date(),
                        user: currentUser.email 
                    });
                    console.log('‚úÖ Escritura testeada');
                    await deleteDoc(testDoc);
                    console.log('‚úÖ Borrado testeado');
                    alert('‚úÖ Firebase funcionando correctamente');
                } else {
                    alert('‚ùå Firebase no disponible');
                }
            } catch (error) {
                console.error('‚ùå Error en test:', error);
                alert('‚ùå Error: ' + error.message);
            }
        };

        window.showFirebaseStatus = function() {
            const status = {
                'App inicializada': !!app,
                'DB inicializada': !!db,
                'Auth inicializado': !!auth,
                'Usuario autenticado': !!currentUser,
                'Usuario email': currentUser?.email || 'No',
                'Firebase conectado': firebaseConnected,
                'Autorizado': isAuthorized
            };
            
            console.table(status);
            alert('Revisa la consola para el estado completo');
        };

        window.diagnoseFirebaseIssue = async function() {
            console.log('=== DIAGN√ìSTICO FIREBASE DETALLADO ===');
            
            if (!currentUser) {
                console.log('‚ùå No hay usuario autenticado');
                return;
            }
            
            console.log('üë§ Usuario:', currentUser.email);
            console.log('üîë UID:', currentUser.uid);
            
            const testOperations = [
                { name: 'Listar jugadas', operation: () => getDocs(query(collection(db, "users", currentUser.uid, "plays"))) },
                { name: 'Leer jugada espec√≠fica', operation: () => getDoc(doc(db, "users", currentUser.uid, "plays", "SCRUM")) },
                { name: 'Escribir test', operation: () => setDoc(doc(db, "users", currentUser.uid, "plays", "test-diagnostic"), { test: true, timestamp: new Date() }) }
            ];
            
            for (const op of testOperations) {
                try {
                    console.log(`üß™ Probando: ${op.name}...`);
                    const result = await op.operation();
                    console.log(`‚úÖ ${op.name}: OK`);
                    
                    if (op.name === 'Listar jugadas' && result) {
                        console.log(`    üìä Documentos encontrados: ${result.size}`);
                        result.forEach(doc => {
                            console.log(`    - ${doc.id}:`, doc.data().name || 'sin nombre');
                        });
                    }
                } catch (error) {
                    console.error(`‚ùå ${op.name}:`, error.code, error.message);
                    
                    if (error.code === 'permission-denied') {
                        console.error('    üî• PROBLEMA DE PERMISOS EN:', op.name);
                        console.error('    üí° Soluci√≥n: Actualiza las reglas de Firebase para permitir:', op.name.split(' ')[0].toLowerCase());
                    }
                }
            }
            
            console.log('=== FIN DIAGN√ìSTICO ===');
        };

        window.fixFirebaseConnection = async function() {
            console.log('üîÑ Intentando reconectar a Firebase...');
            firebaseConnected = false;
            AuthManager.updateFirebaseStatus(false);
            
            setTimeout(async () => {
                const connected = await AuthManager.testFirebaseConnection();
                if (connected) {
                    alert('‚úÖ Conexi√≥n a Firebase restaurada!');
                    StorageManager.updatePlaySelect();
                } else {
                    alert('‚ùå No se pudo conectar a Firebase. Verifica las reglas de seguridad.');
                }
            }, 1000);
        };

        init();
    </script>
</body>
</html>
